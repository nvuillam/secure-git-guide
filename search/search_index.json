{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\ud83d\udea8 Secure Git Guide \ud83d\udea8 Here we attempt to help any developer to use GIT and GitHub more securely. Any challenges that we are facing in terms of security will be registered here. You will find information on how to use GIT securely in development work. This guide is the result of our team actively developing a pure GIT / GitHub infrastructure for repository optimization and automation during which we encountered security challenges. This is a website based on a WIP repository where we will be adding new things as we keep developing. The contents takes two forms: articles and lists of resources. Topics that are covered among others: GPG and how we use it for projects. GPG basic and more advanced uses in relation to GIT and GitHub. GitHub secrets, tokens, etc. GIT vs GitHub differences. etc. Suggestions, petitions on articles, contributions, etc \ud83e\udd13\ud83e\udd21\ud83d\udc4d If you would like to contribute with your experience, have a question or would like to make a correction or suggestion. You are more than welcome. We encourage you to tell us. This is a team effort meant to benefit everyone. If you would like to do so, please go and open a discussion on the topic, challenge you are facing, improvement we could make etc. We are all ears . The way we work is simple: A new discussion is opened We discuss it publicly with you If it makes a new addition to the guide we create an issue. You can create the new document or extend or amend an existing one Here is the link to setting up a new discussion, we look forward to it: https://github.com/Nautilus-Cyberneering/secure-git-guide/discussions . We will be eternally thankful and add you to our credits at the bottom of our index. Articles \ud83d\udd11\ud83d\udd12 What is GPG? ( gpg ) Why we use GPG ( gpg , github ) GPG 101 - How to get your first GPG Keys ( gpg ) How to use GPG with GIT and GitHub ( gpg , github ) Best Practices ( gpg ) Other Uses ( gpg ) How to create a subkey for signing ( gpg ) How to use a signing key independently from the primary key ( gpg ) Git commits partially verified ( gpg , github ) How to remove commits by their commit message ( github ) How to import the dependabot GPG public key ( gpg , github ) How GitHub Actions can get access to secrets ( github ) Sharing GitHub secrets with third-party actions ( github , gh-actions ) How to use Git as a database ( git ) Resources Curated List of Resources ( gpg , github ) Suggestions and Contact If you would like to contact us or make any suggestions or comments please do so via: A new issue in our GitHub repository: https://github.com/Nautilus-Cyberneering/secure-git-guide/issues or Email: info@nautilus-cyberneering.de \ud83d\udc51\ud83d\udc51\ud83d\udc51 Credits \ud83d\udc51\ud83d\udc51\ud83d\udc51 Thank you to all the contributors from our team at Nautilus Cyberneering!!!","title":"Home"},{"location":"#secure-git-guide","text":"Here we attempt to help any developer to use GIT and GitHub more securely. Any challenges that we are facing in terms of security will be registered here. You will find information on how to use GIT securely in development work. This guide is the result of our team actively developing a pure GIT / GitHub infrastructure for repository optimization and automation during which we encountered security challenges. This is a website based on a WIP repository where we will be adding new things as we keep developing. The contents takes two forms: articles and lists of resources. Topics that are covered among others: GPG and how we use it for projects. GPG basic and more advanced uses in relation to GIT and GitHub. GitHub secrets, tokens, etc. GIT vs GitHub differences. etc.","title":"\ud83d\udea8 Secure Git Guide \ud83d\udea8"},{"location":"#suggestions-petitions-on-articles-contributions-etc","text":"If you would like to contribute with your experience, have a question or would like to make a correction or suggestion. You are more than welcome. We encourage you to tell us. This is a team effort meant to benefit everyone. If you would like to do so, please go and open a discussion on the topic, challenge you are facing, improvement we could make etc. We are all ears . The way we work is simple: A new discussion is opened We discuss it publicly with you If it makes a new addition to the guide we create an issue. You can create the new document or extend or amend an existing one Here is the link to setting up a new discussion, we look forward to it: https://github.com/Nautilus-Cyberneering/secure-git-guide/discussions . We will be eternally thankful and add you to our credits at the bottom of our index.","title":"Suggestions, petitions on articles, contributions, etc \ud83e\udd13\ud83e\udd21\ud83d\udc4d"},{"location":"#articles","text":"What is GPG? ( gpg ) Why we use GPG ( gpg , github ) GPG 101 - How to get your first GPG Keys ( gpg ) How to use GPG with GIT and GitHub ( gpg , github ) Best Practices ( gpg ) Other Uses ( gpg ) How to create a subkey for signing ( gpg ) How to use a signing key independently from the primary key ( gpg ) Git commits partially verified ( gpg , github ) How to remove commits by their commit message ( github ) How to import the dependabot GPG public key ( gpg , github ) How GitHub Actions can get access to secrets ( github ) Sharing GitHub secrets with third-party actions ( github , gh-actions ) How to use Git as a database ( git )","title":"Articles \ud83d\udd11\ud83d\udd12"},{"location":"#resources","text":"Curated List of Resources ( gpg , github )","title":"Resources"},{"location":"#suggestions-and-contact","text":"If you would like to contact us or make any suggestions or comments please do so via: A new issue in our GitHub repository: https://github.com/Nautilus-Cyberneering/secure-git-guide/issues or Email: info@nautilus-cyberneering.de","title":"Suggestions and Contact"},{"location":"#credits","text":"Thank you to all the contributors from our team at Nautilus Cyberneering!!!","title":"\ud83d\udc51\ud83d\udc51\ud83d\udc51 Credits \ud83d\udc51\ud83d\udc51\ud83d\udc51"},{"location":"001_GPG-What-is-GPG/","text":"GPG - What is GPG Note: Source WIKIPEDIA Brief Summary GNU Privacy Guard (GnuPG or GPG) is a free-software replacement for Symantec's PGP cryptographic software suite. The software is compliant with RFC 4880, the IETF standards-track specification of OpenPGP. Modern versions of PGP are interoperable with GnuPG and other OpenPGP-compliant systems. Overview GnuPG is a hybrid-encryption software program because it uses a combination of conventional symmetric-key cryptography for speed, and public-key cryptography for ease of secure key exchange, typically by using the recipient's public key to encrypt a session key which is used only once. This mode of operation is part of the OpenPGP standard and has been part of PGP from its first version. The GnuPG 1.x series uses an integrated cryptographic library, while the GnuPG 2.x series replaces this with Libgcrypt. GnuPG encrypts messages using asymmetric key pairs individually generated by GnuPG users. The resulting public keys may be exchanged with other users in a variety of ways, such as Internet key servers. They must always be exchanged carefully to prevent identity spoofing by corrupting public key \u2194 \"owner\" identity correspondences. It is also possible to add a cryptographic digital signature to a message, so the message integrity and sender can be verified, if a particular correspondence relied upon has not been corrupted. GnuPG also supports symmetric encryption algorithms. By default, GnuPG uses the AES symmetrical algorithm since version 2.1, CAST5 was used in earlier versions. GnuPG does not use patented or otherwise restricted software or algorithms. Instead, GnuPG uses a variety of other, non-patented algorithms. For a long time, it did not support the IDEA encryption algorithm used in PGP. It was in fact possible to use IDEA in GnuPG by downloading a plugin for it, however, this might require a license for some uses in countries in which IDEA was patented. Starting with versions 1.4.13 and 2.0.20, GnuPG supports IDEA because the last patent of IDEA expired in 2012. Support of IDEA is intended \"to get rid of all the questions from folks either trying to decrypt old data or migrating keys from PGP to GnuPG\", and hence is not recommended for regular use. As of 2.2 versions, GnuPG supports the following algorithms: Public key RSA, ElGamal, DSA, ECDH, ECDSA, EdDSA Cipher 3DES, IDEA (since versions 1.4.13 and 2.0.20), CAST5, Blowfish, Twofish, AES-128, AES-192, AES-256, Camellia-128, -192 and -256 (since versions 1.4.10 and 2.0.12) Hash MD5, SHA-1, RIPEMD-160, SHA-256, SHA-384, SHA-512, SHA-224 Compression Uncompressed, ZIP, ZLIB, BZIP2 More recent releases of GnuPG 2.x (\"modern\" and the now deprecated \"stable\" series) expose most cryptographic functions and algorithms Libgcrypt (its cryptography library) provides, including support for elliptic curve cryptography (ECDH, ECDSA and EdDSA) in the \"modern\" series (i.e. since GnuPG 2.1). Note: Source WIKIPEDIA Back to home","title":"GPG - What is GPG"},{"location":"001_GPG-What-is-GPG/#gpg-what-is-gpg","text":"Note: Source WIKIPEDIA","title":"GPG - What is GPG"},{"location":"001_GPG-What-is-GPG/#brief-summary","text":"GNU Privacy Guard (GnuPG or GPG) is a free-software replacement for Symantec's PGP cryptographic software suite. The software is compliant with RFC 4880, the IETF standards-track specification of OpenPGP. Modern versions of PGP are interoperable with GnuPG and other OpenPGP-compliant systems.","title":"Brief Summary"},{"location":"001_GPG-What-is-GPG/#overview","text":"GnuPG is a hybrid-encryption software program because it uses a combination of conventional symmetric-key cryptography for speed, and public-key cryptography for ease of secure key exchange, typically by using the recipient's public key to encrypt a session key which is used only once. This mode of operation is part of the OpenPGP standard and has been part of PGP from its first version. The GnuPG 1.x series uses an integrated cryptographic library, while the GnuPG 2.x series replaces this with Libgcrypt. GnuPG encrypts messages using asymmetric key pairs individually generated by GnuPG users. The resulting public keys may be exchanged with other users in a variety of ways, such as Internet key servers. They must always be exchanged carefully to prevent identity spoofing by corrupting public key \u2194 \"owner\" identity correspondences. It is also possible to add a cryptographic digital signature to a message, so the message integrity and sender can be verified, if a particular correspondence relied upon has not been corrupted. GnuPG also supports symmetric encryption algorithms. By default, GnuPG uses the AES symmetrical algorithm since version 2.1, CAST5 was used in earlier versions. GnuPG does not use patented or otherwise restricted software or algorithms. Instead, GnuPG uses a variety of other, non-patented algorithms. For a long time, it did not support the IDEA encryption algorithm used in PGP. It was in fact possible to use IDEA in GnuPG by downloading a plugin for it, however, this might require a license for some uses in countries in which IDEA was patented. Starting with versions 1.4.13 and 2.0.20, GnuPG supports IDEA because the last patent of IDEA expired in 2012. Support of IDEA is intended \"to get rid of all the questions from folks either trying to decrypt old data or migrating keys from PGP to GnuPG\", and hence is not recommended for regular use. As of 2.2 versions, GnuPG supports the following algorithms:","title":"Overview"},{"location":"001_GPG-What-is-GPG/#public-key","text":"RSA, ElGamal, DSA, ECDH, ECDSA, EdDSA","title":"Public key"},{"location":"001_GPG-What-is-GPG/#cipher","text":"3DES, IDEA (since versions 1.4.13 and 2.0.20), CAST5, Blowfish, Twofish, AES-128, AES-192, AES-256, Camellia-128, -192 and -256 (since versions 1.4.10 and 2.0.12)","title":"Cipher"},{"location":"001_GPG-What-is-GPG/#hash","text":"MD5, SHA-1, RIPEMD-160, SHA-256, SHA-384, SHA-512, SHA-224","title":"Hash"},{"location":"001_GPG-What-is-GPG/#compression","text":"Uncompressed, ZIP, ZLIB, BZIP2 More recent releases of GnuPG 2.x (\"modern\" and the now deprecated \"stable\" series) expose most cryptographic functions and algorithms Libgcrypt (its cryptography library) provides, including support for elliptic curve cryptography (ECDH, ECDSA and EdDSA) in the \"modern\" series (i.e. since GnuPG 2.1). Note: Source WIKIPEDIA Back to home","title":"Compression"},{"location":"002_GPG-Why-we-use-GPG/","text":"GPG - Why we use GPG The main reason to use GPG in our daily work is to make sure that our contributions to the company's repositories belong to one of its active contributors or maintainers. We use it to prevent impersonation attacks. GPG is one of the options for commit signing used with GitHub. It is the preferred option by our team members. Why to use it? Advantages For authentication, certification and signing the receiving end can verify that the content is from you, having your public key. On the other hand, if the other party wants to send you something only for you, they will use your public encryption key in combination with their own private key to sign and certify the content. Such content can only be decrypted using your own private key, and by having their public key you will know that it is from them. First advantage: If someone sends to you something encrypted, meant only for you, you will be the only one capable of decrypting it. \"All right but why now, so many keys?\" Essentially there is one primary key, which is typically used only for signing and certification, and a subkey signed by the primary key for encryption. However, you can have one for each of the usages if you wanted. Second advantage: Each subkey when used is transmitted at the same time, but if compromised it can be revoked individually and a new key generated while keeping your primary key valid. It makes it easier to manage your keys and split them for the different purposes you want to use them. Disadvantage If your primary key is compromised or you lose it, your security has been breached and someone can impersonate you or you lose access to your digital \"id\" stemming from this key.... you may have to start building your digital reputation from scratch. Nevertheless, for this situation there exists the revocation certificate which is created from the start at the same time that you create your keys for the first time or at any given time for the individual keys you want to revoke. With this certificate you would have to go to the before mentioned GPG key servers and upload it, to publicly revoke the affected key or keys. Back to home","title":"GPG - Why we use GPG"},{"location":"002_GPG-Why-we-use-GPG/#gpg-why-we-use-gpg","text":"The main reason to use GPG in our daily work is to make sure that our contributions to the company's repositories belong to one of its active contributors or maintainers. We use it to prevent impersonation attacks. GPG is one of the options for commit signing used with GitHub. It is the preferred option by our team members.","title":"GPG - Why we use GPG"},{"location":"002_GPG-Why-we-use-GPG/#why-to-use-it","text":"","title":"Why to use it?"},{"location":"002_GPG-Why-we-use-GPG/#advantages","text":"For authentication, certification and signing the receiving end can verify that the content is from you, having your public key. On the other hand, if the other party wants to send you something only for you, they will use your public encryption key in combination with their own private key to sign and certify the content. Such content can only be decrypted using your own private key, and by having their public key you will know that it is from them. First advantage: If someone sends to you something encrypted, meant only for you, you will be the only one capable of decrypting it. \"All right but why now, so many keys?\" Essentially there is one primary key, which is typically used only for signing and certification, and a subkey signed by the primary key for encryption. However, you can have one for each of the usages if you wanted. Second advantage: Each subkey when used is transmitted at the same time, but if compromised it can be revoked individually and a new key generated while keeping your primary key valid. It makes it easier to manage your keys and split them for the different purposes you want to use them.","title":"Advantages"},{"location":"002_GPG-Why-we-use-GPG/#disadvantage","text":"If your primary key is compromised or you lose it, your security has been breached and someone can impersonate you or you lose access to your digital \"id\" stemming from this key.... you may have to start building your digital reputation from scratch. Nevertheless, for this situation there exists the revocation certificate which is created from the start at the same time that you create your keys for the first time or at any given time for the individual keys you want to revoke. With this certificate you would have to go to the before mentioned GPG key servers and upload it, to publicly revoke the affected key or keys. Back to home","title":"Disadvantage"},{"location":"003-GPG-101-How-to-get-your-first-GPG-Keys/","text":"GPG - 101 - How to get your first GPG Keys Installing GPG The steps to install GPG on your computer are the following: Download the necessary software for your Operating System at: Windows Linux - Installed through terminal Mac OS GPG4Win Kleopatra Generating your own new GPG Keys Generating your own new GPG Keys is extremely easy. Here is a series of screenshots of the process using the Kleopatra application for Windows. (1) (2) It is extremely important to use a passphrase and more important if you use it to actually write it down somewhere so that you never loose it. (3) (4) (5) (6) (7) (8) (9) (10) (11) Creating a Revocation Certificate (1) (2) (3) (4) Sample Public GPG Key Command Line or Terminal In order to generate your new keys you have two options: Running the default setup. Running the full setup which lets you define some additional specifications such as the encryption level. Default Setup Open the command line as an admin and type: ```terminal gpg --gen-keys ``` (1) (2) (3) (4) (5) (6) Once this has been done the keys get generated with the default encryption level of 3072. Full Setup This option lets you: Define the encryption level up to 4096. Insert a comment. Define the key type (RSA, DSA, Elgamal, etc.). It automatically generates also a revocation certificate at the default location which is indicated at the final step. Open the command line as an admin and type: ```terminal gpg --full-generate-keys ``` Defining the key type (1) (2) Defining the encryption level (3) (4) Defining the expiration date (5) (6) (7) Defining the user ID to identify the key (8) (9) (10) (11) Final screen with revocation certificate location (12) Back to home","title":"GPG - 101 - How to get your first GPG Keys"},{"location":"003-GPG-101-How-to-get-your-first-GPG-Keys/#gpg-101-how-to-get-your-first-gpg-keys","text":"","title":"GPG - 101 - How to get your first GPG Keys"},{"location":"003-GPG-101-How-to-get-your-first-GPG-Keys/#installing-gpg","text":"The steps to install GPG on your computer are the following: Download the necessary software for your Operating System at: Windows Linux - Installed through terminal Mac OS","title":"Installing GPG"},{"location":"003-GPG-101-How-to-get-your-first-GPG-Keys/#gpg4win-kleopatra","text":"","title":"GPG4Win Kleopatra"},{"location":"003-GPG-101-How-to-get-your-first-GPG-Keys/#generating-your-own-new-gpg-keys","text":"Generating your own new GPG Keys is extremely easy. Here is a series of screenshots of the process using the Kleopatra application for Windows. (1) (2) It is extremely important to use a passphrase and more important if you use it to actually write it down somewhere so that you never loose it. (3) (4) (5) (6) (7) (8) (9) (10) (11)","title":"Generating your own new GPG Keys"},{"location":"003-GPG-101-How-to-get-your-first-GPG-Keys/#creating-a-revocation-certificate","text":"(1) (2) (3) (4)","title":"Creating a Revocation Certificate"},{"location":"003-GPG-101-How-to-get-your-first-GPG-Keys/#sample-public-gpg-key","text":"","title":"Sample Public GPG Key"},{"location":"003-GPG-101-How-to-get-your-first-GPG-Keys/#command-line-or-terminal","text":"In order to generate your new keys you have two options: Running the default setup. Running the full setup which lets you define some additional specifications such as the encryption level.","title":"Command Line or Terminal"},{"location":"003-GPG-101-How-to-get-your-first-GPG-Keys/#default-setup","text":"Open the command line as an admin and type: ```terminal gpg --gen-keys ``` (1) (2) (3) (4) (5) (6) Once this has been done the keys get generated with the default encryption level of 3072.","title":"Default Setup"},{"location":"003-GPG-101-How-to-get-your-first-GPG-Keys/#full-setup","text":"This option lets you: Define the encryption level up to 4096. Insert a comment. Define the key type (RSA, DSA, Elgamal, etc.). It automatically generates also a revocation certificate at the default location which is indicated at the final step. Open the command line as an admin and type: ```terminal gpg --full-generate-keys ```","title":"Full Setup"},{"location":"003-GPG-101-How-to-get-your-first-GPG-Keys/#defining-the-key-type","text":"(1) (2)","title":"Defining the key type"},{"location":"003-GPG-101-How-to-get-your-first-GPG-Keys/#defining-the-encryption-level","text":"(3) (4)","title":"Defining the encryption level"},{"location":"003-GPG-101-How-to-get-your-first-GPG-Keys/#defining-the-expiration-date","text":"(5) (6) (7)","title":"Defining the expiration date"},{"location":"003-GPG-101-How-to-get-your-first-GPG-Keys/#defining-the-user-id-to-identify-the-key","text":"(8) (9) (10) (11)","title":"Defining the user ID to identify the key"},{"location":"003-GPG-101-How-to-get-your-first-GPG-Keys/#final-screen-with-revocation-certificate-location","text":"(12) Back to home","title":"Final screen with revocation certificate location"},{"location":"004_GPG-How-to-use-GPG-with-GIT-and-GitHub/","text":"GPG - How to use GPG with GIT and GitHub In order to use the GPG Keys Github and GIT develop two easy to follow guidelines. Git - https://git-scm.com/book/en/v2/Git-Tools-Signing-Your-Work GitHub - https://docs.github.com/en/authentication/managing-commit-signature-verification/signing-commits Back to home","title":"GPG - How to use GPG with GIT and GitHub"},{"location":"004_GPG-How-to-use-GPG-with-GIT-and-GitHub/#gpg-how-to-use-gpg-with-git-and-github","text":"In order to use the GPG Keys Github and GIT develop two easy to follow guidelines. Git - https://git-scm.com/book/en/v2/Git-Tools-Signing-Your-Work GitHub - https://docs.github.com/en/authentication/managing-commit-signature-verification/signing-commits Back to home","title":"GPG - How to use GPG with GIT and GitHub"},{"location":"005_GPG-Best-Practices/","text":"GPG - Best Practices Understanding GPG Defaults There are many arrangement and possible combinations of keys, sub-keys, user-id's and so on. When you use GPG to generate your keys, by default it generates your keys following a standard template: Keys Primary Key (Certify and Signing) Supplementary Key (Encrypting) User-ID Primary ID (Name, Email, and Comment) You can notice that the primary key has been set with the dual-capabilities of Certifying (to make new supplementary keys) and Signing (such as signing a Git commit). This basis structure was chosen upon the thought that the keys used for Encryption need to be (or at least should be) rotated regularly, however Signing can remain constant over the lifetime of the OpenPGP Key. However, in many cases this is not what the user would want if given the choice. Why is this not optimal? The default set-up leaves still some space for improvement. This is because it does not take advantage of the possibility to create individual sub-keys for each capability. The idea is that you essentially disconnect all the rights of your choice from your primary key and just use your sub-keys to avoid using your primary key. The only times you then use your primary is to cancel (revoke) existing sub-keys or to generate new sub-keys. It is very advanced to separate the primary key from the supplementary keys. The advantage of this approach is that if any of these sub-keys gets compromised, you can revoke individually and generate a new key, all while keeping your primary key valid. If you do not do this, you probably will end up someday with your primary key compromised and will have to regenerate a new primary key, etc. Recommended Best Practices ====================================================================== How to create further sub-keys In order to create additional sub-keys, you need to use the GPG command-line interface. You can read a very clear step-by-step guide here . I base the following summary of steps in the command line interface on his work. Type: terminal gpg --list-keys --fingerprint --with-keygrip --with-subkey-fingerprints In the list you get an overview of all the primary key and its existing sub-keys. You will copy the second line of your public key made up of 10 pairs of 4 numbers and or letters. Using the noted public key type: terminal gpg --edit-key <public key 40 digits without spaces> You will get a display of their associated private key and a new prompt so type: terminal addkey Select your applicable key, most likely option (4) RSA (sign only) It will ask you to specify the keysize duration, I recommend 4096 and \"0\" for does not expire. Confirm the creation. You get a new overview of the new secret keys, seeing the newly generated sub-key and the changed rights of the primary key. To see the equivalent public keys for export type: terminal gpg --list-keys --fingerprint --with-keygrip --with-subkey-fingerprints <public key 40 digits without spaces> You should now see the new sub-key and the changed primary key rights. Removing primary key rights The last step to finish this is to remove all capabilities except the \"certify\" capability from the primary key. For this, you will continue using the command line but using the \"expert\" mode. Type: terminal gpg --expert --edit-key <public key 40 digits without spaces> You will get an overview of the primary key's rights. Type: terminal change-usage Use the toggle option taking away the rights for which you already have created the new sub-key. Once you are done you get a new overview of the primary key's rights. Type save and you are all set working on the keys. Type: terminal gpg --list-keys --fingerprint --with-keygrip --with-subkey-fingerprints <public key 40 digits without spaces> You will see the new public key rights where you should only see the \"c\" option for certify at the \"pub\" key. Configuring Git with your new key In order to set up your new key for signing your commits you have to follow these steps: In the command prompt type: terminal git config --global --edit</code> This will open the git config file in your default editor. In my case it opens it in Visual Code. Once here look for the following entry of the signing-key and update it with the last 16 digits of your new signing sub-key. Save it. If you are using GitHub you will need to export your new public key and import it into it, following the necessary steps as shown in their GitHub Documentation - Signing commits . Always use a Passphrase :exclamation When creating the set of keys you are asked for a passphrase. Set it and remember it or even better write it down somewhere. This is another safety measure but it is essential. Backing up Your Revocation Certificate :exclamation Make sure that you keep a backup of your revocation certificate or that you print it out and store it somewhere safe in case that you were to have to use it. Rotating Your Encryption Keys :exclamation This being one of the most used capabilities. It is recommended that you rotate these keys to prevent anyone to have access to any of your encrypted information, creating for example new keys in events such as computer change, etc. It is important though to back these up in the event that you were to have files encrypted with these. Setting an Expiration Date :exclamation Another good idea is to set an expiration date not too far in the future in case that you were to not be able to revoke your certificate due to having lost your revocation certificate. Back to home","title":"GPG - Best Practices"},{"location":"005_GPG-Best-Practices/#gpg-best-practices","text":"","title":"GPG - Best Practices"},{"location":"005_GPG-Best-Practices/#understanding-gpg-defaults","text":"There are many arrangement and possible combinations of keys, sub-keys, user-id's and so on. When you use GPG to generate your keys, by default it generates your keys following a standard template: Keys Primary Key (Certify and Signing) Supplementary Key (Encrypting) User-ID Primary ID (Name, Email, and Comment) You can notice that the primary key has been set with the dual-capabilities of Certifying (to make new supplementary keys) and Signing (such as signing a Git commit). This basis structure was chosen upon the thought that the keys used for Encryption need to be (or at least should be) rotated regularly, however Signing can remain constant over the lifetime of the OpenPGP Key. However, in many cases this is not what the user would want if given the choice.","title":"Understanding GPG Defaults"},{"location":"005_GPG-Best-Practices/#why-is-this-not-optimal","text":"The default set-up leaves still some space for improvement. This is because it does not take advantage of the possibility to create individual sub-keys for each capability. The idea is that you essentially disconnect all the rights of your choice from your primary key and just use your sub-keys to avoid using your primary key. The only times you then use your primary is to cancel (revoke) existing sub-keys or to generate new sub-keys. It is very advanced to separate the primary key from the supplementary keys. The advantage of this approach is that if any of these sub-keys gets compromised, you can revoke individually and generate a new key, all while keeping your primary key valid. If you do not do this, you probably will end up someday with your primary key compromised and will have to regenerate a new primary key, etc.","title":"Why is this not optimal?"},{"location":"005_GPG-Best-Practices/#recommended-best-practices","text":"======================================================================","title":"Recommended Best Practices"},{"location":"005_GPG-Best-Practices/#how-to-create-further-sub-keys","text":"In order to create additional sub-keys, you need to use the GPG command-line interface. You can read a very clear step-by-step guide here . I base the following summary of steps in the command line interface on his work. Type: terminal gpg --list-keys --fingerprint --with-keygrip --with-subkey-fingerprints In the list you get an overview of all the primary key and its existing sub-keys. You will copy the second line of your public key made up of 10 pairs of 4 numbers and or letters. Using the noted public key type: terminal gpg --edit-key <public key 40 digits without spaces> You will get a display of their associated private key and a new prompt so type: terminal addkey Select your applicable key, most likely option (4) RSA (sign only) It will ask you to specify the keysize duration, I recommend 4096 and \"0\" for does not expire. Confirm the creation. You get a new overview of the new secret keys, seeing the newly generated sub-key and the changed rights of the primary key. To see the equivalent public keys for export type: terminal gpg --list-keys --fingerprint --with-keygrip --with-subkey-fingerprints <public key 40 digits without spaces> You should now see the new sub-key and the changed primary key rights.","title":"How to create further sub-keys"},{"location":"005_GPG-Best-Practices/#removing-primary-key-rights","text":"The last step to finish this is to remove all capabilities except the \"certify\" capability from the primary key. For this, you will continue using the command line but using the \"expert\" mode. Type: terminal gpg --expert --edit-key <public key 40 digits without spaces> You will get an overview of the primary key's rights. Type: terminal change-usage Use the toggle option taking away the rights for which you already have created the new sub-key. Once you are done you get a new overview of the primary key's rights. Type save and you are all set working on the keys. Type: terminal gpg --list-keys --fingerprint --with-keygrip --with-subkey-fingerprints <public key 40 digits without spaces> You will see the new public key rights where you should only see the \"c\" option for certify at the \"pub\" key.","title":"Removing primary key rights"},{"location":"005_GPG-Best-Practices/#configuring-git-with-your-new-key","text":"In order to set up your new key for signing your commits you have to follow these steps: In the command prompt type: terminal git config --global --edit</code> This will open the git config file in your default editor. In my case it opens it in Visual Code. Once here look for the following entry of the signing-key and update it with the last 16 digits of your new signing sub-key. Save it. If you are using GitHub you will need to export your new public key and import it into it, following the necessary steps as shown in their GitHub Documentation - Signing commits .","title":"Configuring Git with your new key"},{"location":"005_GPG-Best-Practices/#always-use-a-passphrase-exclamation","text":"When creating the set of keys you are asked for a passphrase. Set it and remember it or even better write it down somewhere. This is another safety measure but it is essential.","title":"Always use a Passphrase :exclamation"},{"location":"005_GPG-Best-Practices/#backing-up-your-revocation-certificate-exclamation","text":"Make sure that you keep a backup of your revocation certificate or that you print it out and store it somewhere safe in case that you were to have to use it.","title":"Backing up Your Revocation Certificate :exclamation"},{"location":"005_GPG-Best-Practices/#rotating-your-encryption-keys-exclamation","text":"This being one of the most used capabilities. It is recommended that you rotate these keys to prevent anyone to have access to any of your encrypted information, creating for example new keys in events such as computer change, etc. It is important though to back these up in the event that you were to have files encrypted with these.","title":"Rotating Your Encryption Keys :exclamation"},{"location":"005_GPG-Best-Practices/#setting-an-expiration-date-exclamation","text":"Another good idea is to set an expiration date not too far in the future in case that you were to not be able to revoke your certificate due to having lost your revocation certificate. Back to home","title":"Setting an Expiration Date :exclamation"},{"location":"006_GPG-Other-Uses/","text":"GPG - Other Uses As for other uses. The most usual are encryption and email. Here are some good links to these: EMAIL Thunderbird -- https://enigmail.net/index.php/en/ Outlook -- https://www.comparitech.com/blog/information-security/pgp-encryption-with-outlook/ Gmail -- https://www.comparitech.com/blog/information-security/pgp-encryption-gmail/ A list of Front End Applications using GPG keys Various -- https://gnupg.org/software/frontends.html Back to home","title":"GPG - Other Uses"},{"location":"006_GPG-Other-Uses/#gpg-other-uses","text":"As for other uses. The most usual are encryption and email. Here are some good links to these:","title":"GPG - Other Uses"},{"location":"006_GPG-Other-Uses/#email","text":"Thunderbird -- https://enigmail.net/index.php/en/ Outlook -- https://www.comparitech.com/blog/information-security/pgp-encryption-with-outlook/ Gmail -- https://www.comparitech.com/blog/information-security/pgp-encryption-gmail/","title":"EMAIL"},{"location":"006_GPG-Other-Uses/#a-list-of-front-end-applications-using-gpg-keys","text":"Various -- https://gnupg.org/software/frontends.html Back to home","title":"A list of Front End Applications using GPG keys"},{"location":"007_Curated-List-of-Resources/","text":"Curated List of Resources Index: GPG Git GitHub GPG Downloads & Installation (GPG) https://gnupg.org/ https://gpg4win.org/ https://linuxhint.com/gpg-command-ubuntu/ Uses (GPG) Git -- https://docs.github.com/en/authentication/managing-commit-signature-verification/signing-commits GitHub -- https://git-scm.com/book/en/v2/Git-Tools-Signing-Your-Work Email and other uses -- https://www.openpgp.org/ Various -- https://gnupg.org/software/frontends.html Best Practices (GPG) https://github.com/josecelano/pygithub/blob/main/docs/how_to_create_a_subkey_for_signing.md Definition (GPG) https://en.wikipedia.org/wiki/GNU_Privacy_Guard Good Articles (GPG) https://blog.ghostinthemachines.com/2015/03/01/how-to-use-gpg-command-line/ Git Downloads & Installation (Git) Official Site - https://git-scm.com/downloads Best Practices (Git) 7 Git Best Practices to Start using in your next Commit Security best practices for git users Definition (Git) https://en.wikipedia.org/wiki/Git Great Resource (Git) Git Magic Resource (Very extensive and documented) covers Git to some extent and focuses GitHub Awesome List of resources for Git and Github Books (Git) Official Git Pro eBook (free) Git GitHub Downloads & Installation (GitHub) GitHub is an online platform service so that in essence you do not need to install anything to start using it. Official Online Site - https://github.com/ GitHub Documentation Best Practices (GitHub) Good starter - GitHub Best Practices (NC State) 10 GitHub Best Practices Some important concepts - Best Practices for GitHub Repositories Definition (GitHub) https://en.wikipedia.org/wiki/GitHub Great Resource (GitHub) Git Magic Resource (Very extensive and documented) covers Git to some extent and focuses GitHub Awesome List of resources for Git and Github Books Git Essentials Back to home","title":"Curated List of Resources"},{"location":"007_Curated-List-of-Resources/#curated-list-of-resources","text":"Index: GPG Git GitHub","title":"Curated List of Resources"},{"location":"007_Curated-List-of-Resources/#gpg","text":"","title":"GPG"},{"location":"007_Curated-List-of-Resources/#downloads-installation-gpg","text":"https://gnupg.org/ https://gpg4win.org/ https://linuxhint.com/gpg-command-ubuntu/","title":"Downloads &amp; Installation (GPG)"},{"location":"007_Curated-List-of-Resources/#uses-gpg","text":"Git -- https://docs.github.com/en/authentication/managing-commit-signature-verification/signing-commits GitHub -- https://git-scm.com/book/en/v2/Git-Tools-Signing-Your-Work Email and other uses -- https://www.openpgp.org/ Various -- https://gnupg.org/software/frontends.html","title":"Uses (GPG)"},{"location":"007_Curated-List-of-Resources/#best-practices-gpg","text":"https://github.com/josecelano/pygithub/blob/main/docs/how_to_create_a_subkey_for_signing.md","title":"Best Practices (GPG)"},{"location":"007_Curated-List-of-Resources/#definition-gpg","text":"https://en.wikipedia.org/wiki/GNU_Privacy_Guard","title":"Definition (GPG)"},{"location":"007_Curated-List-of-Resources/#good-articles-gpg","text":"https://blog.ghostinthemachines.com/2015/03/01/how-to-use-gpg-command-line/","title":"Good Articles (GPG)"},{"location":"007_Curated-List-of-Resources/#git","text":"","title":"Git"},{"location":"007_Curated-List-of-Resources/#downloads-installation-git","text":"Official Site - https://git-scm.com/downloads","title":"Downloads &amp; Installation (Git)"},{"location":"007_Curated-List-of-Resources/#best-practices-git","text":"7 Git Best Practices to Start using in your next Commit Security best practices for git users","title":"Best Practices (Git)"},{"location":"007_Curated-List-of-Resources/#definition-git","text":"https://en.wikipedia.org/wiki/Git","title":"Definition (Git)"},{"location":"007_Curated-List-of-Resources/#great-resource-git","text":"Git Magic Resource (Very extensive and documented) covers Git to some extent and focuses GitHub Awesome List of resources for Git and Github","title":"Great Resource (Git)"},{"location":"007_Curated-List-of-Resources/#books-git","text":"Official Git Pro eBook (free) Git","title":"Books (Git)"},{"location":"007_Curated-List-of-Resources/#github","text":"","title":"GitHub"},{"location":"007_Curated-List-of-Resources/#downloads-installation-github","text":"GitHub is an online platform service so that in essence you do not need to install anything to start using it. Official Online Site - https://github.com/ GitHub Documentation","title":"Downloads &amp; Installation (GitHub)"},{"location":"007_Curated-List-of-Resources/#best-practices-github","text":"Good starter - GitHub Best Practices (NC State) 10 GitHub Best Practices Some important concepts - Best Practices for GitHub Repositories","title":"Best Practices (GitHub)"},{"location":"007_Curated-List-of-Resources/#definition-github","text":"https://en.wikipedia.org/wiki/GitHub","title":"Definition (GitHub)"},{"location":"007_Curated-List-of-Resources/#great-resource-github","text":"Git Magic Resource (Very extensive and documented) covers Git to some extent and focuses GitHub Awesome List of resources for Git and Github","title":"Great Resource (GitHub)"},{"location":"007_Curated-List-of-Resources/#books","text":"Git Essentials Back to home","title":"Books"},{"location":"008_GPG-How-to-create-a-subkey-for-signing/","text":"How to create a subkey for signing By default, when you create a new GPG key, what you create is a pair of keys: The Primary Key A subkey for encryption. This is a sample output: pub rsa3072 2022-03-03 [SC] 9DE3 32FB 25C8 A2D6 EDF9 DE8E B5B5 8E7C A8F5 6B98 uid [ultimate] Test User <test.user@example.com> sub rsa3072 2022-03-03 [E] As you can see, the primary key is valid for certification and signing. A much better approach is to use also a different subkey for signing. You can read a full explanation on why that's a better solution in this article about GPG subkeys . Git and GitHub official documentation promotes using the GPG keys the way they are created by default. If you want to sign commits and you do not know how to do it, you will probably end up reading Git or GitHub official documentation: Git Documentation - Git Tools - Signing Your Work GitHub Documentation - Signing commits In those documents, they promote the use of the master or primary key. Or at least, it's what they use. They probably do not want to overwhelm the reader with a lot of GPG technical stuff. If you list one of your GPG keys you will see something like: gpg --list-keys --fingerprint --with-keygrip --with-subkey-fingerprints 88966A5B8C01BD04F3DA440427304EDD6079B81C pub rsa4096 2021-11-19 [SC] 8896 6A5B 8C01 BD04 F3DA 4404 2730 4EDD 6079 B81C Keygrip = 449972AC9FF11BCABEED8A7AE834C4349CC4DBFF uid [ultimate] A committer <committer@example.com> sub rsa4096 2021-11-19 [E] B1D4 A248 3D1D 2A02 416B E077 5B6B DD35 BEDF BF6F Keygrip = 97D36F5B8F5BECDA8A1923FC00D11C7C438584F9 The meaning for the letters inside brackets are the GPG key capabilities : Character Capability S Sign C Certify E Encrypt A Authentication If you want to create a signing key, you can follow Debian's post . If you do it the output would be something like: gpg --edit-key 88966A5B8C01BD04F3DA440427304EDD6079B81C gpg (GnuPG) 2.2.19; Copyright (C) 2019 Free Software Foundation, Inc. This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Secret key is available. sec rsa4096/27304EDD6079B81C created: 2021-11-19 expires: never usage: SC trust: ultimate validity: ultimate ssb rsa4096/5B6BDD35BEDFBF6F created: 2021-11-19 expires: never usage: E [ultimate] (1). A committer <committer@example.com> gpg> addkey Please select what kind of key you want: (3) DSA (sign only) (4) RSA (sign only) (5) Elgamal (encrypt only) (6) RSA (encrypt only) (14) Existing key from card Your selection? 4 RSA keys may be between 1024 and 4096 bits long. What keysize do you want? (3072) 4096 Requested keysize is 4096 bits Please specify how long the key should be valid. 0 = key does not expire <n> = key expires in n days <n>w = key expires in n weeks <n>m = key expires in n months <n>y = key expires in n years Key is valid for? (0) Key does not expire at all Is this correct? (y/N) y Really create? (y/N) y We need to generate a lot of random bytes. It is a good idea to perform some other action (type on the keyboard, move the mouse, utilize the disks) during the prime generation; this gives the random number generator a better chance to gain enough entropy. sec rsa4096/27304EDD6079B81C created: 2021-11-19 expires: never usage: SC trust: ultimate validity: ultimate ssb rsa4096/5B6BDD35BEDFBF6F created: 2021-11-19 expires: never usage: E ssb rsa4096/3F39AA1432CA6AD7 created: 2021-11-26 expires: never usage: S [ultimate] (1). A committer <committer@example.com> gpg> save And this is the key including also keygrips: gpg --list-keys --fingerprint --with-keygrip --with-subkey-fingerprints 88966A5B8C01BD04F3DA440427304EDD6079B81C pub rsa4096 2021-11-19 [SC] 8896 6A5B 8C01 BD04 F3DA 4404 2730 4EDD 6079 B81C Keygrip = 449972AC9FF11BCABEED8A7AE834C4349CC4DBFF uid [ultimate] A committer <committer@example.com> sub rsa4096 2021-11-19 [E] B1D4 A248 3D1D 2A02 416B E077 5B6B DD35 BEDF BF6F Keygrip = 97D36F5B8F5BECDA8A1923FC00D11C7C438584F9 sub rsa4096 2021-11-26 [S] BD98 B3F4 2545 FF93 EFF5 5F7F 3F39 AA14 32CA 6AD7 Keygrip = 00CB9308AE0B6DE018C5ADBAB29BA7899D6062BE If for example, you want to use that subkey to sign git commits, you can replace your git config with: [user] name = Your Name email = your@email.com signingkey = B29BA7899D6062BE You should remove all the capabilities from the primary key except for \"Certify\" ([C]). You can do it by editing the primary key in expert mode. You have to use the option change-usage which is a \"hidden\" option (not listed with the help command) gpg --expert --edit-key 88966A5B8C01BD04F3DA440427304EDD6079B81C gpg (GnuPG) 2.2.19; Copyright (C) 2019 Free Software Foundation, Inc. This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Secret key is available. sec rsa4096/27304EDD6079B81C created: 2021-11-19 expires: never usage: SC trust: ultimate validity: ultimate ssb rsa4096/5B6BDD35BEDFBF6F created: 2021-11-19 expires: never usage: E ssb rsa4096/3F39AA1432CA6AD7 created: 2021-11-26 expires: never usage: S [ultimate] (1). A committer <committer@example.com> gpg> change-usage Changing usage of the primary key. Possible actions for a RSA key: Sign Certify Encrypt Authenticate Current allowed actions: Sign Certify (S) Toggle the sign capability (E) Toggle the encrypt capability (A) Toggle the authenticate capability (Q) Finished Your selection? S Possible actions for a RSA key: Sign Certify Encrypt Authenticate Current allowed actions: Certify (S) Toggle the sign capability (E) Toggle the encrypt capability (A) Toggle the authenticate capability (Q) Finished Your selection? Q sec rsa4096/27304EDD6079B81C created: 2021-11-19 expires: never usage: C trust: ultimate validity: ultimate ssb rsa4096/5B6BDD35BEDFBF6F created: 2021-11-19 expires: never usage: E ssb rsa4096/3F39AA1432CA6AD7 created: 2021-11-26 expires: never usage: S [ultimate] (1). A committer <committer@example.com> gpg> save After editing the key you should see only the [C] capability on the primary key. gpg -k /home/josecelano/.gnupg/pubring.kbx ----------------------------------- pub rsa4096 2021-11-19 [C] 88966A5B8C01BD04F3DA440427304EDD6079B81C uid [ultimate] A committer <committer@example.com> sub rsa4096 2021-11-19 [E] sub rsa4096 2021-11-26 [S] Links Using OpenPGP subkeys in Debian development Create GnuPG key with sub-keys to sign, encrypt, authenticate Generate GPG Master and Subkeys GPG - Subkeys GPG Subkeys Creating a new GPG key with subkeys Generating More Secure GPG Keys: Rationale Back to home","title":"How to create a subkey for signing"},{"location":"008_GPG-How-to-create-a-subkey-for-signing/#how-to-create-a-subkey-for-signing","text":"By default, when you create a new GPG key, what you create is a pair of keys: The Primary Key A subkey for encryption. This is a sample output: pub rsa3072 2022-03-03 [SC] 9DE3 32FB 25C8 A2D6 EDF9 DE8E B5B5 8E7C A8F5 6B98 uid [ultimate] Test User <test.user@example.com> sub rsa3072 2022-03-03 [E] As you can see, the primary key is valid for certification and signing. A much better approach is to use also a different subkey for signing. You can read a full explanation on why that's a better solution in this article about GPG subkeys . Git and GitHub official documentation promotes using the GPG keys the way they are created by default. If you want to sign commits and you do not know how to do it, you will probably end up reading Git or GitHub official documentation: Git Documentation - Git Tools - Signing Your Work GitHub Documentation - Signing commits In those documents, they promote the use of the master or primary key. Or at least, it's what they use. They probably do not want to overwhelm the reader with a lot of GPG technical stuff. If you list one of your GPG keys you will see something like: gpg --list-keys --fingerprint --with-keygrip --with-subkey-fingerprints 88966A5B8C01BD04F3DA440427304EDD6079B81C pub rsa4096 2021-11-19 [SC] 8896 6A5B 8C01 BD04 F3DA 4404 2730 4EDD 6079 B81C Keygrip = 449972AC9FF11BCABEED8A7AE834C4349CC4DBFF uid [ultimate] A committer <committer@example.com> sub rsa4096 2021-11-19 [E] B1D4 A248 3D1D 2A02 416B E077 5B6B DD35 BEDF BF6F Keygrip = 97D36F5B8F5BECDA8A1923FC00D11C7C438584F9 The meaning for the letters inside brackets are the GPG key capabilities : Character Capability S Sign C Certify E Encrypt A Authentication If you want to create a signing key, you can follow Debian's post . If you do it the output would be something like: gpg --edit-key 88966A5B8C01BD04F3DA440427304EDD6079B81C gpg (GnuPG) 2.2.19; Copyright (C) 2019 Free Software Foundation, Inc. This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Secret key is available. sec rsa4096/27304EDD6079B81C created: 2021-11-19 expires: never usage: SC trust: ultimate validity: ultimate ssb rsa4096/5B6BDD35BEDFBF6F created: 2021-11-19 expires: never usage: E [ultimate] (1). A committer <committer@example.com> gpg> addkey Please select what kind of key you want: (3) DSA (sign only) (4) RSA (sign only) (5) Elgamal (encrypt only) (6) RSA (encrypt only) (14) Existing key from card Your selection? 4 RSA keys may be between 1024 and 4096 bits long. What keysize do you want? (3072) 4096 Requested keysize is 4096 bits Please specify how long the key should be valid. 0 = key does not expire <n> = key expires in n days <n>w = key expires in n weeks <n>m = key expires in n months <n>y = key expires in n years Key is valid for? (0) Key does not expire at all Is this correct? (y/N) y Really create? (y/N) y We need to generate a lot of random bytes. It is a good idea to perform some other action (type on the keyboard, move the mouse, utilize the disks) during the prime generation; this gives the random number generator a better chance to gain enough entropy. sec rsa4096/27304EDD6079B81C created: 2021-11-19 expires: never usage: SC trust: ultimate validity: ultimate ssb rsa4096/5B6BDD35BEDFBF6F created: 2021-11-19 expires: never usage: E ssb rsa4096/3F39AA1432CA6AD7 created: 2021-11-26 expires: never usage: S [ultimate] (1). A committer <committer@example.com> gpg> save And this is the key including also keygrips: gpg --list-keys --fingerprint --with-keygrip --with-subkey-fingerprints 88966A5B8C01BD04F3DA440427304EDD6079B81C pub rsa4096 2021-11-19 [SC] 8896 6A5B 8C01 BD04 F3DA 4404 2730 4EDD 6079 B81C Keygrip = 449972AC9FF11BCABEED8A7AE834C4349CC4DBFF uid [ultimate] A committer <committer@example.com> sub rsa4096 2021-11-19 [E] B1D4 A248 3D1D 2A02 416B E077 5B6B DD35 BEDF BF6F Keygrip = 97D36F5B8F5BECDA8A1923FC00D11C7C438584F9 sub rsa4096 2021-11-26 [S] BD98 B3F4 2545 FF93 EFF5 5F7F 3F39 AA14 32CA 6AD7 Keygrip = 00CB9308AE0B6DE018C5ADBAB29BA7899D6062BE If for example, you want to use that subkey to sign git commits, you can replace your git config with: [user] name = Your Name email = your@email.com signingkey = B29BA7899D6062BE You should remove all the capabilities from the primary key except for \"Certify\" ([C]). You can do it by editing the primary key in expert mode. You have to use the option change-usage which is a \"hidden\" option (not listed with the help command) gpg --expert --edit-key 88966A5B8C01BD04F3DA440427304EDD6079B81C gpg (GnuPG) 2.2.19; Copyright (C) 2019 Free Software Foundation, Inc. This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Secret key is available. sec rsa4096/27304EDD6079B81C created: 2021-11-19 expires: never usage: SC trust: ultimate validity: ultimate ssb rsa4096/5B6BDD35BEDFBF6F created: 2021-11-19 expires: never usage: E ssb rsa4096/3F39AA1432CA6AD7 created: 2021-11-26 expires: never usage: S [ultimate] (1). A committer <committer@example.com> gpg> change-usage Changing usage of the primary key. Possible actions for a RSA key: Sign Certify Encrypt Authenticate Current allowed actions: Sign Certify (S) Toggle the sign capability (E) Toggle the encrypt capability (A) Toggle the authenticate capability (Q) Finished Your selection? S Possible actions for a RSA key: Sign Certify Encrypt Authenticate Current allowed actions: Certify (S) Toggle the sign capability (E) Toggle the encrypt capability (A) Toggle the authenticate capability (Q) Finished Your selection? Q sec rsa4096/27304EDD6079B81C created: 2021-11-19 expires: never usage: C trust: ultimate validity: ultimate ssb rsa4096/5B6BDD35BEDFBF6F created: 2021-11-19 expires: never usage: E ssb rsa4096/3F39AA1432CA6AD7 created: 2021-11-26 expires: never usage: S [ultimate] (1). A committer <committer@example.com> gpg> save After editing the key you should see only the [C] capability on the primary key. gpg -k /home/josecelano/.gnupg/pubring.kbx ----------------------------------- pub rsa4096 2021-11-19 [C] 88966A5B8C01BD04F3DA440427304EDD6079B81C uid [ultimate] A committer <committer@example.com> sub rsa4096 2021-11-19 [E] sub rsa4096 2021-11-26 [S]","title":"How to create a subkey for signing"},{"location":"008_GPG-How-to-create-a-subkey-for-signing/#links","text":"Using OpenPGP subkeys in Debian development Create GnuPG key with sub-keys to sign, encrypt, authenticate Generate GPG Master and Subkeys GPG - Subkeys GPG Subkeys Creating a new GPG key with subkeys Generating More Secure GPG Keys: Rationale Back to home","title":"Links"},{"location":"009_GPG-How-to-use-a-signing-key-independently-from-primary-key/","text":"GPG - How to use a signing key independently from the primary key Creating a subkey only for signing is considered a good practice, instead of using the primary key. If you want to know why you can read this article . In that article we explain how to create that signing subkey and use it in your computer. We also explain how to upload the public key to GitHub if you want to verify your Git commits. Sometimes you want to use the private subkey on other machines and you should only expose the private key of the subkey. One use case for that is signing commits on CI/CD. If you are using for example GitHub Actions, you could use a GitHub Action to import GPG private keys . After importing the private key you can sign new commits that are automatically created on the GitHub runners during the workflow executions. You could upload the full export of the GPG key but ideally you should upload (as GitHub secret) only the private key of the key you are using for signing. In order to do that you need to export the subkey independently from the primary key. How to export only one private subkey from a GPG key Given you have a key like the following one with a signing subkey ( 8505CFE38CF47C8CBCF0C9D7FC47DBB5210FB475 ): gpg -k --with-subkey-fingerprint 9DE332FB25C8A2D6EDF9DE8EB5B58E7CA8F56B98 pub rsa3072 2022-03-03 [C] 9DE332FB25C8A2D6EDF9DE8EB5B58E7CA8F56B98 uid [ultimate] Test User <test.user@example.com> sub rsa3072 2022-03-03 [E] 850CF85F94AF49D149273E1746BD4F801229C887 sub rsa3072 2022-03-03 [S] 8505CFE38CF47C8CBCF0C9D7FC47DBB5210FB475 You can export the private key for the subkey with: gpg --armor --export-secret-subkeys 8505CFE38CF47C8CBCF0C9D7FC47DBB5210FB475! > ~/Backups/primary_key.9DE332FB25C8A2D6EDF9DE8EB5B58E7CA8F56B98.sub_key.8505CFE38CF47C8CBCF0C9D7FC47DBB5210FB475.independent.secret.asc You can also test the export by importing the same key in a different keyring. GPG works with a directory where it stores all the keys. That directory is called homedir . You can change the homedir using a command option --homedir . So you can create a new directory and import the key backup there: $ mkdir /tmp/import-only-subkey && cd /tmp/import-only-subkey $ gpg --homedir=/tmp/import-only-subkey --import ~/Backups/primary_key.9DE332FB25C8A2D6EDF9DE8EB5B58E7CA8F56B98.sub_key.8505CFE38CF47C8CBCF0C9D7FC47DBB5210FB475.independent.secret.asc gpg: key B5B58E7CA8F56B98: public key \"Test User <test.user@example.com>\" imported gpg: To migrate 'secring.gpg', with each smartcard, run: gpg --card-status gpg: key B5B58E7CA8F56B98: secret key imported gpg: Total number processed: 1 gpg: imported: 1 gpg: secret keys read: 1 gpg: secret keys imported: 1 If you list the private keys in that keyring you will see that the key still contains the public key for the primary key, even thought we only exported the subkey. But it does not include the other encryption subkey: $ gpg --homedir=/tmp/import-only-subkey -k --with-subkey-fingerprint 8505CFE38CF47C8CBCF0C9D7FC47DBB5210FB475 pub rsa3072 2022-03-03 [C] 9DE332FB25C8A2D6EDF9DE8EB5B58E7CA8F56B98 uid [ unknown] Test User <test.user@example.com> sub rsa3072 2022-03-03 [S] 8505CFE38CF47C8CBCF0C9D7FC47DBB5210FB475 Now you can export it again and use it whenever you want to use it independently from the primary key. For example, as a GitHub secret used in a CI/CD process. How to change the passphrase for the subkey In the process above you have to use the same passphrase for the original key and the independent subkey. Unfortunately you can not change the passphrase when you export the key. If you want to use a different passphrase for the subkey you have to change it later. $ gpg --homedir=/tmp/import-only-subkey --edit-key 8505CFE38CF47C8CBCF0C9D7FC47DBB5210FB475 gpg (GnuPG) 2.2.20; Copyright (C) 2020 Free Software Foundation, Inc. This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Secret subkeys are available. pub rsa3072/B5B58E7CA8F56B98 created: 2022-03-03 expires: never usage: C trust: unknown validity: unknown ssb rsa3072/FC47DBB5210FB475 created: 2022-03-03 expires: never usage: S [ unknown] (1). Test User <test.user@example.com> gpg> passwd gpg: key B5B58E7CA8F56B98/B5B58E7CA8F56B98: error changing passphrase: No secret key gpg> save Key not changed so no update needed. You have to enter the current password and the new one twice. You will get this error: gpg: key B5B58E7CA8F56B98/B5B58E7CA8F56B98: error changing passphrase: No secret key That means GPG did not change the passphrase for the primary key, because there was not any private key for the primary key, but the passphrase was in fact changed. If you try to change the passphrase again with passwd you will see that the old password does not work anymore. Back to home","title":"GPG - How to use a signing key independently from the primary key"},{"location":"009_GPG-How-to-use-a-signing-key-independently-from-primary-key/#gpg-how-to-use-a-signing-key-independently-from-the-primary-key","text":"Creating a subkey only for signing is considered a good practice, instead of using the primary key. If you want to know why you can read this article . In that article we explain how to create that signing subkey and use it in your computer. We also explain how to upload the public key to GitHub if you want to verify your Git commits. Sometimes you want to use the private subkey on other machines and you should only expose the private key of the subkey. One use case for that is signing commits on CI/CD. If you are using for example GitHub Actions, you could use a GitHub Action to import GPG private keys . After importing the private key you can sign new commits that are automatically created on the GitHub runners during the workflow executions. You could upload the full export of the GPG key but ideally you should upload (as GitHub secret) only the private key of the key you are using for signing. In order to do that you need to export the subkey independently from the primary key.","title":"GPG - How to use a signing key independently from the primary key"},{"location":"009_GPG-How-to-use-a-signing-key-independently-from-primary-key/#how-to-export-only-one-private-subkey-from-a-gpg-key","text":"Given you have a key like the following one with a signing subkey ( 8505CFE38CF47C8CBCF0C9D7FC47DBB5210FB475 ): gpg -k --with-subkey-fingerprint 9DE332FB25C8A2D6EDF9DE8EB5B58E7CA8F56B98 pub rsa3072 2022-03-03 [C] 9DE332FB25C8A2D6EDF9DE8EB5B58E7CA8F56B98 uid [ultimate] Test User <test.user@example.com> sub rsa3072 2022-03-03 [E] 850CF85F94AF49D149273E1746BD4F801229C887 sub rsa3072 2022-03-03 [S] 8505CFE38CF47C8CBCF0C9D7FC47DBB5210FB475 You can export the private key for the subkey with: gpg --armor --export-secret-subkeys 8505CFE38CF47C8CBCF0C9D7FC47DBB5210FB475! > ~/Backups/primary_key.9DE332FB25C8A2D6EDF9DE8EB5B58E7CA8F56B98.sub_key.8505CFE38CF47C8CBCF0C9D7FC47DBB5210FB475.independent.secret.asc You can also test the export by importing the same key in a different keyring. GPG works with a directory where it stores all the keys. That directory is called homedir . You can change the homedir using a command option --homedir . So you can create a new directory and import the key backup there: $ mkdir /tmp/import-only-subkey && cd /tmp/import-only-subkey $ gpg --homedir=/tmp/import-only-subkey --import ~/Backups/primary_key.9DE332FB25C8A2D6EDF9DE8EB5B58E7CA8F56B98.sub_key.8505CFE38CF47C8CBCF0C9D7FC47DBB5210FB475.independent.secret.asc gpg: key B5B58E7CA8F56B98: public key \"Test User <test.user@example.com>\" imported gpg: To migrate 'secring.gpg', with each smartcard, run: gpg --card-status gpg: key B5B58E7CA8F56B98: secret key imported gpg: Total number processed: 1 gpg: imported: 1 gpg: secret keys read: 1 gpg: secret keys imported: 1 If you list the private keys in that keyring you will see that the key still contains the public key for the primary key, even thought we only exported the subkey. But it does not include the other encryption subkey: $ gpg --homedir=/tmp/import-only-subkey -k --with-subkey-fingerprint 8505CFE38CF47C8CBCF0C9D7FC47DBB5210FB475 pub rsa3072 2022-03-03 [C] 9DE332FB25C8A2D6EDF9DE8EB5B58E7CA8F56B98 uid [ unknown] Test User <test.user@example.com> sub rsa3072 2022-03-03 [S] 8505CFE38CF47C8CBCF0C9D7FC47DBB5210FB475 Now you can export it again and use it whenever you want to use it independently from the primary key. For example, as a GitHub secret used in a CI/CD process.","title":"How to export only one private subkey from a GPG key"},{"location":"009_GPG-How-to-use-a-signing-key-independently-from-primary-key/#how-to-change-the-passphrase-for-the-subkey","text":"In the process above you have to use the same passphrase for the original key and the independent subkey. Unfortunately you can not change the passphrase when you export the key. If you want to use a different passphrase for the subkey you have to change it later. $ gpg --homedir=/tmp/import-only-subkey --edit-key 8505CFE38CF47C8CBCF0C9D7FC47DBB5210FB475 gpg (GnuPG) 2.2.20; Copyright (C) 2020 Free Software Foundation, Inc. This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Secret subkeys are available. pub rsa3072/B5B58E7CA8F56B98 created: 2022-03-03 expires: never usage: C trust: unknown validity: unknown ssb rsa3072/FC47DBB5210FB475 created: 2022-03-03 expires: never usage: S [ unknown] (1). Test User <test.user@example.com> gpg> passwd gpg: key B5B58E7CA8F56B98/B5B58E7CA8F56B98: error changing passphrase: No secret key gpg> save Key not changed so no update needed. You have to enter the current password and the new one twice. You will get this error: gpg: key B5B58E7CA8F56B98/B5B58E7CA8F56B98: error changing passphrase: No secret key That means GPG did not change the passphrase for the primary key, because there was not any private key for the primary key, but the passphrase was in fact changed. If you try to change the passphrase again with passwd you will see that the old password does not work anymore. Back to home","title":"How to change the passphrase for the subkey"},{"location":"010_GPG-Git-commits-partially-verified/","text":"GPG - Git commits partially verified On GitHub , you can enable vigilant mode for commit signature verification . That means that GitHub will verify the signature of your commits and it will show a message like this: It will verify not only the commits were you are the committer but also commits where you are the author. That is the straightforward case. However, there are some cases where you can get unexpected behaviour. We will describe some corner cases regarding signing git commits, but before that, we have to explain some basic Git concepts related to commit signatures. Basic Git concepts related to commit signatures Committer vs author The \"committer\" is the person who executes the commit command git commit . Git gets the committer name and email from the Git configuration, and it is usually the global configuration. $ git config -l | grep user user.name=Jose Celano user.email=josecelano@gmail.com user.signingkey=58508C7950C7B7A2 If you do not specify an author, Git assumes that the author is the same as the committer. You can also override the committer and the author using environment variables: GIT_AUTHOR_NAME GIT_AUTHOR_EMAIL GIT_COMMITTER_NAME GIT_COMMITTER_EMAIL For the author you have a command option too ( git commit -m \"...\" --author=\"Your Name <your@email.com>\" ). Commit signature in Git Git also allows you to sign a commit with a GPG key. From the Git official documentation about GPG signature : The command which is about to create an object (commit) determines a payload from that, calls gpg to obtain a detached signature for the payload (gpg -bsa) and embeds the signature into the object or transaction. You can use any GPG key. Usually the GPG user ID matches the committer info. If you have this configuration in your ~/.gitconfig file: $ cat ~/.gitconfig [user] name = A committer email = committer@example.com signingkey = BD98B3F42545FF93EFF55F7F3F39AA1432CA6AD7 You will probably have a GPG key like this: gpg -k --with-subkey-fingerprint 88966A5B8C01BD04F3DA440427304EDD6079B81C pub rsa4096 2021-11-19 [C] 88966A5B8C01BD04F3DA440427304EDD6079B81C uid [ultimate] A committer <committer@example.com> sub rsa4096 2021-11-19 [E] B1D4A2483D1D2A02416BE0775B6BDD35BEDFBF6F sub rsa4096 2021-11-26 [S] BD98B3F42545FF93EFF55F7F3F39AA1432CA6AD7 In Git you can commit using a different committer and author, and also with a GPG key with a different user ID. GIT_COMMITTER_NAME=\"Jose Celano [bot]\" \\ GIT_COMMITTER_EMAIL=\"bot@josecelano.com\" \\ GIT_AUTHOR_NAME=\"Jose Celano\" \\ GIT_AUTHOR_EMAIL=\"josecelano@gmail.com\" \\ git commit --gpg-sign=BD98B3F42545FF93EFF55F7F3F39AA1432CA6AD7 -m \"commit message\" This is how the commit looks`: commit d89b296e9d58cc4281aeead172b170739acc164c (HEAD -> main) gpg: Signature made jue 12 may 2022 15:36:29 WEST gpg: using RSA key BD98B3F42545FF93EFF55F7F3F39AA1432CA6AD7 gpg: Good signature from \"A committer <committer@example.com>\" [ultimate] Author: Jose Celano <josecelano@gmail.com> AuthorDate: Thu May 12 15:36:29 2022 +0100 Commit: Jose Celano [bot] <bot@josecelano.com> CommitDate: Thu May 12 15:36:29 2022 +0100 commit message Commit signature on GitHub That is how Git works, but GitHub does not work exactly like Git. On the GitHub Documentation you can read: Note: When asked to enter your email address, ensure that you enter the verified email address for your GitHub account. To keep your email address private, use your GitHub-provided no-reply email address. For more information, see \"Verifying your email address\" and \"Setting your commit email address.\" GitHub forces you to a use a GPG key whose user ID matches one of your GitHub account emails, so that when GitHub verified the signature not only verifies that the signature is OK but it also verifies that committer's email and account email match. You should only enable vigilant mode if you sign all of your commits and tags and use an email address that is verified for your account on GitHub as your committer email address. GitHub shows you a simplified version of Git. Because it links the GPG key to the committer. Although is not a Git constraint it is a common practice. GitLab seems to do exactly the same: For GitLab to consider a commit verified: The committer must have a GPG public/private key pair. The committer\u2019s public key must be uploaded to their GitLab account. One of the email addresses in the GPG public key must match a verified email address used by the committer in GitLab. To keep this address private, use the automatically generated private commit email address GitLab provides in your profile. The committer\u2019s email address must match the verified email address from the GPG key. For the rest of this article we assume that the GPG key fulfills the requirements in the GitLab documentation. We do not know if GitHub has exactly the same restrictions as we have not found documentation about it. Git commit with multiple GPG signatures Git does not allow to add more than one GPG signature to a commit. What Git does is generate the commit object and sign it with GPG. The signature is then added as a commit header . We have not found a reason why Git does not support multiple signatures. Since Git only relays on the GPG console command, we thought the reason was that GPG did not support it either, but as you can read on this Stackoverflow answer , there are two ways to add multiple signatures to a file using GPG. The first solution is to sign the contents with one key and sign the result again with the following key until you sign it with all the keys. The second solution would be using \"detached signatures\", which means the signature is not included in the signed document. We suppose Git could have used this approach, and this article from Owen Jacobson( describes it in detail. But it is not the case. Although Git uses \"detached signatures\", the signature is included as a commit header inside the \"full\" commit object that is used to calculate the commit hash. That means changing the signature changes the commit hash. Git merge, rebase and GPG signature So, we know that Git does not allow including the author's signature and the committer's signature. We have the restriction that you can only add one signature to each commit. That means you will permanently lose the author's signature when you commit someone else's code. You could include the author's signature instead of the committer's one but that is not an standard practice. If you want to include the author's signature your can keep the original commit, for example, by using git merge (with a merge commit) to merge branches. We will see whether that is important or not, why it is crucial, and how you can deal with this problem. However, before that, we need to understand what happens when a committer specifies a different author and other cases where the author changes automatically. When you use the git rebase command with a different committer than the original commits, Git will keep the original author as the author of the newly generated commits. echo \"Initialize repo\" mkdir /tmp/git-test cd /tmp/git-test/ git init echo \"Add a file as maintainer\" touch a.txt git add -A GIT_COMMITTER_NAME=\"maintainer\" \\ GIT_COMMITTER_EMAIL=\"maintainer@email.com\" \\ GIT_AUTHOR_NAME=\"maintainer\" \\ GIT_AUTHOR_EMAIL=\"maintainer@email.com\" \\ git commit --no-gpg-sign -m \"add a.txt\" echo \"Add a file as contributor on a topic branch\" git checkout -b topic-branch touch b.txt git add -A GIT_COMMITTER_NAME=\"contributor\" \\ GIT_COMMITTER_EMAIL=\"contributor@email.com\" \\ GIT_AUTHOR_NAME=\"contributor\" \\ GIT_AUTHOR_EMAIL=\"contributor@email.com\" \\ git commit --no-gpg-sign -m \"add b.txt\" git show --pretty=fuller HEAD echo \"Add another file as maintainer on the main branch\" git checkout main touch c.txt git add -A GIT_COMMITTER_NAME=\"maintainer\" \\ GIT_COMMITTER_EMAIL=\"maintainer@email.com\" \\ GIT_AUTHOR_NAME=\"maintainer\" \\ GIT_AUTHOR_EMAIL=\"maintainer@email.com\" \\ git commit --no-gpg-sign -m \"add c.txt\" echo \"Rebase topic-branch as maintainer\" git checkout topic-branch GIT_COMMITTER_NAME=\"maintainer\" \\ GIT_COMMITTER_EMAIL=\"maintainer@email.com\" \\ GIT_AUTHOR_NAME=\"maintainer\" \\ GIT_AUTHOR_EMAIL=\"maintainer@email.com\" \\ git rebase main git log --pretty=fuller If you execute the script, you will see the original contributor commit: commit 148628f7f3f0f0a908ab5889e066eba842f4da66 (HEAD -> topic-branch) Author: contributor <contributor@email.com> AuthorDate: Mon May 2 15:43:09 2022 +0100 Commit: contributor <contributor@email.com> CommitDate: Mon May 2 15:43:09 2022 +0100 add b.txt And the commit after the rebase: commit 71f8feb30f8b02f26ddee67385152e25a774704f (HEAD -> topic-branch) Author: contributor <contributor@email.com> AuthorDate: Mon May 2 15:43:09 2022 +0100 Commit: maintainer <maintainer@email.com> CommitDate: Mon May 2 15:43:09 2022 +0100 add b.txt If you merge the topic-branch into the main branch with fast-forward: git checkout main GIT_COMMITTER_NAME=\"maintainer\" \\ GIT_COMMITTER_EMAIL=\"maintainer@email.com\" \\ git merge --ff-only topic-branch you will have the same commit 71f8feb30f8b02f26ddee67385152e25a774704f re-created by the maintainer in the main branch. git show --pretty=fuller HEAD commit 71f8feb30f8b02f26ddee67385152e25a774704f (HEAD -> main, topic-branch) Author: contributor <contributor@email.com> AuthorDate: Mon May 2 15:43:09 2022 +0100 Commit: maintainer <maintainer@email.com> CommitDate: Mon May 2 15:43:09 2022 +0100 add b.txt As you can see, Git keeps the author ( contributor <contributor@email.com> ) of the original commit. On the other hand, the maintainer could merge the topic-branch with a merge commit: echo \"Initialize repo\" mkdir /tmp/git-test cd /tmp/git-test/ git init echo \"Add a file as maintainer\" touch a.txt git add -A GIT_COMMITTER_NAME=\"maintainer\" \\ GIT_COMMITTER_EMAIL=\"maintainer@email.com\" \\ GIT_AUTHOR_NAME=\"maintainer\" \\ GIT_AUTHOR_EMAIL=\"maintainer@email.com\" \\ git commit --no-gpg-sign -m \"add a.txt\" echo \"Add a file as contributor on a topic branch\" git checkout -b topic-branch touch b.txt git add -A GIT_COMMITTER_NAME=\"contributor\" \\ GIT_COMMITTER_EMAIL=\"contributor@email.com\" \\ GIT_AUTHOR_NAME=\"contributor\" \\ GIT_AUTHOR_EMAIL=\"contributor@email.com\" \\ git commit --no-gpg-sign -m \"add b.txt\" git show --pretty=fuller HEAD echo \"Merge topic-branch as maintainer\" git checkout main GIT_COMMITTER_NAME=\"maintainer\" \\ GIT_COMMITTER_EMAIL=\"maintainer@email.com\" \\ GIT_AUTHOR_NAME=\"maintainer\" \\ GIT_AUTHOR_EMAIL=\"maintainer@email.com\" \\ git merge --no-ff topic-branch git log --pretty=fuller In this case, the contributor commit looks the same as in the previous example before rebasing: commit ac3b9f8eef024c30e59c01bce4943ad0597fab9c (HEAD -> topic-branch) Author: contributor <contributor@email.com> AuthorDate: Mon May 2 15:52:37 2022 +0100 Commit: contributor <contributor@email.com> CommitDate: Mon May 2 15:52:37 2022 +0100 add b.txt And after merging: commit 1b75bfb9d0b4621560bf2c6158e937ea457bb4e5 (HEAD -> main) Merge: 097e6ee ac3b9f8 Author: maintainer <maintainer@email.com> AuthorDate: Mon May 2 15:52:37 2022 +0100 Commit: maintainer <maintainer@email.com> CommitDate: Mon May 2 15:52:37 2022 +0100 Merge branch 'topic-branch' commit 097e6ee7f0088a54ec22712ce18fd08904d954b8 Author: maintainer <maintainer@email.com> AuthorDate: Mon May 2 15:52:37 2022 +0100 Commit: maintainer <maintainer@email.com> CommitDate: Mon May 2 15:52:37 2022 +0100 add a.txt commit ac3b9f8eef024c30e59c01bce4943ad0597fab9c (topic-branch) Author: contributor <contributor@email.com> AuthorDate: Mon May 2 15:52:37 2022 +0100 Commit: contributor <contributor@email.com> CommitDate: Mon May 2 15:52:37 2022 +0100 add b.txt You still have the original commit ac3b9f8eef024c30e59c01bce4943ad0597fab9c and the new merge commit 1b75bfb9d0b4621560bf2c6158e937ea457bb4e5 . Notice that you have to specify the author again for the git merge commit. Otherwise, the author would be your default committer info. For the git merge --ff-only topic-branch , you do not have to specify the author. Git uses the original commit author. NOTE: we could test what happens when the original commit has a different committer and author. We suppose the author is what is propagated, but we should check it with an example. If we were using GPG signatures, we would have only the committer signature on each final commit. NOTE: GitHub \"rebase and merge\" button does not work exactly as Git rebase . On GitHub documentation, you can read: \"The rebase and merge behavior on GitHub deviates slightly from Git rebase. Rebase and merge on GitHub will always update the committer information and create new commit SHAs, whereas Git rebase outside of GitHub does not change the committer information when the rebase happens on top of an ancestor commit. For more information about Git rebase, see git-rebase in the Git documentation.\" When it is possible to merge with fast-forward, Git will not change the original committer info. If you rerun the merge example using rebase with fast-forward: echo \"Initialize repo\" mkdir /tmp/git-test cd /tmp/git-test/ git init echo \"Add a file as maintainer\" touch a.txt git add -A GIT_COMMITTER_NAME=\"maintainer\" \\ GIT_COMMITTER_EMAIL=\"maintainer@email.com\" \\ GIT_AUTHOR_NAME=\"maintainer\" \\ GIT_AUTHOR_EMAIL=\"maintainer@email.com\" \\ git commit --no-gpg-sign -m \"add a.txt\" echo \"Add a file as contributor on a topic branch\" git checkout -b topic-branch touch b.txt git add -A GIT_COMMITTER_NAME=\"contributor\" \\ GIT_COMMITTER_EMAIL=\"contributor@email.com\" \\ GIT_AUTHOR_NAME=\"contributor\" \\ GIT_AUTHOR_EMAIL=\"contributor@email.com\" \\ git commit --no-gpg-sign -m \"add b.txt\" git show --pretty=fuller HEAD echo \"Merge topic-branch as maintainer\" git checkout main git merge --ff-only topic-branch git log --pretty=fuller The original contributor commits should be something like: commit d81c1a285a1a82fcdd8732ea159a58f66e082e1d (HEAD -> topic-branch) Author: contributor <contributor@email.com> AuthorDate: Mon May 2 16:22:28 2022 +0100 Commit: contributor <contributor@email.com> CommitDate: Mon May 2 16:22:28 2022 +0100 add b.txt And you can see the same commit after the merge: commit d81c1a285a1a82fcdd8732ea159a58f66e082e1d (HEAD -> main, topic-branch) Author: contributor <contributor@email.com> AuthorDate: Mon May 2 16:22:28 2022 +0100 Commit: contributor <contributor@email.com> CommitDate: Mon May 2 16:22:28 2022 +0100 add b.txt commit 176fa5d4b50bacc9e608d4cfad5957bd156da775 Author: maintainer <maintainer@email.com> AuthorDate: Mon May 2 16:22:28 2022 +0100 Commit: maintainer <maintainer@email.com> CommitDate: Mon May 2 16:22:28 2022 +0100 add a.txt That commit keeps the committer and author values. GitHub would override the committer info with the info of the logged-in user. GitHub does something like: git checkout main GIT_COMMITTER_NAME=\"maintainer\" \\ GIT_COMMITTER_EMAIL=\"maintainer@email.com\" \\ git merge --ff-only topic-branch More info on a GitHub blog post . How to keep the chain of trust Now we know: How Git uses the committer and author information. How Git deals with commit signatures. How GitHub works slightly different overwriting the committer info when you use the \"rebase and merge\" on a pull request. What happens when we create a new commit? When a new commit is created, we need to sign it again with the committer GPG key. That leads to two problems: We can lose the commit signature. We lose the author's signature. Let us start with point 1, having not signed commits. If we re-create new commits using rebase, we lose the original author signature, but we can add the maintainer one, as long as we do it in an environment where the GPG private key is available. For example, if you use the \"rebase and merge\" button provided by the GitHub UI, the new commit will not be signed because GitHub does not have the committer signing key. You can use a console command where the maintainer GPG private key is available. That forces you to stop using GitHub UI for merging pull requests if you want all your commits to be signed. Regarding point 2, losing the author's signature, we first must consider why we do not want to lose it. We can consider the signature a mechanism to review/accept changes. If we consider only the maintainers the final responsible for our code, losing the author's signature is not critical, as long as the maintainers make sure changes come from a trusted source. In this case, we are not breaking the trust. It is just that we trust maintainers, and they check signatures for other contributors they trust. The maintainers should ensure that commits on a pull request are signed by contributors they trust before merging them. On the other hand, It would be nice to keep that trust chain transparent so people using a package can check that third-party contributors' changes were accepted without changes. If you do not want to lose the author's signature, one obvious solution is to merge only using merge commits. It is out of the scope of this article to describe the pros and cons of losing or not losing the author's signature. A fascinating article by Mike Gerwitz explains the different alternatives in detail. When this happens on GitHub, you see this message on the commit status (if you have vigilant mode enabled): Maybe losing the author's signature is not an issue from the package user or the maintainers' point of view. However, from the author's point of view, you can not distinguish anymore between your legitimate commits and the fake ones. Someone else could pretend you have collaborated with their project. It is surprisingly easy to do that. You only need to create a commit and override the author with any users on GitHub. Conclusion When you use signed commits: Be aware of the Git limitation of one single signature per commit. Be also aware of what happens to signatures when you use Git commands like \"merge\" and \"rebase\". Define your git branching/merging and release strategy according to your web of trust. Be prepared to stop using the GitHub UI and define your processes and scripts. Links Article by Mike Gerwitz: A Git Horror Story: Repository Integrity With Signed Commits Article by Owen Jacobson: Notes Towards Detached Signatures in Git Stackoverflow: Several GPG signatures for one file Stackoverflow: Git \u2013sign-off feature Hacker News: Git-signatures \u2013 Multiple PGP signatures for your commits Article by Micha\u0142 G\u00f3rny: Attack on git signature verification via crafting multiple signatures Git book: Git Tools - Signing Your Work Git docs: Git signature format Back to home","title":"GPG - Git commits partially verified"},{"location":"010_GPG-Git-commits-partially-verified/#gpg-git-commits-partially-verified","text":"On GitHub , you can enable vigilant mode for commit signature verification . That means that GitHub will verify the signature of your commits and it will show a message like this: It will verify not only the commits were you are the committer but also commits where you are the author. That is the straightforward case. However, there are some cases where you can get unexpected behaviour. We will describe some corner cases regarding signing git commits, but before that, we have to explain some basic Git concepts related to commit signatures.","title":"GPG - Git commits partially verified"},{"location":"010_GPG-Git-commits-partially-verified/#basic-git-concepts-related-to-commit-signatures","text":"","title":"Basic Git concepts related to commit signatures"},{"location":"010_GPG-Git-commits-partially-verified/#committer-vs-author","text":"The \"committer\" is the person who executes the commit command git commit . Git gets the committer name and email from the Git configuration, and it is usually the global configuration. $ git config -l | grep user user.name=Jose Celano user.email=josecelano@gmail.com user.signingkey=58508C7950C7B7A2 If you do not specify an author, Git assumes that the author is the same as the committer. You can also override the committer and the author using environment variables: GIT_AUTHOR_NAME GIT_AUTHOR_EMAIL GIT_COMMITTER_NAME GIT_COMMITTER_EMAIL For the author you have a command option too ( git commit -m \"...\" --author=\"Your Name <your@email.com>\" ).","title":"Committer vs author"},{"location":"010_GPG-Git-commits-partially-verified/#commit-signature-in-git","text":"Git also allows you to sign a commit with a GPG key. From the Git official documentation about GPG signature : The command which is about to create an object (commit) determines a payload from that, calls gpg to obtain a detached signature for the payload (gpg -bsa) and embeds the signature into the object or transaction. You can use any GPG key. Usually the GPG user ID matches the committer info. If you have this configuration in your ~/.gitconfig file: $ cat ~/.gitconfig [user] name = A committer email = committer@example.com signingkey = BD98B3F42545FF93EFF55F7F3F39AA1432CA6AD7 You will probably have a GPG key like this: gpg -k --with-subkey-fingerprint 88966A5B8C01BD04F3DA440427304EDD6079B81C pub rsa4096 2021-11-19 [C] 88966A5B8C01BD04F3DA440427304EDD6079B81C uid [ultimate] A committer <committer@example.com> sub rsa4096 2021-11-19 [E] B1D4A2483D1D2A02416BE0775B6BDD35BEDFBF6F sub rsa4096 2021-11-26 [S] BD98B3F42545FF93EFF55F7F3F39AA1432CA6AD7 In Git you can commit using a different committer and author, and also with a GPG key with a different user ID. GIT_COMMITTER_NAME=\"Jose Celano [bot]\" \\ GIT_COMMITTER_EMAIL=\"bot@josecelano.com\" \\ GIT_AUTHOR_NAME=\"Jose Celano\" \\ GIT_AUTHOR_EMAIL=\"josecelano@gmail.com\" \\ git commit --gpg-sign=BD98B3F42545FF93EFF55F7F3F39AA1432CA6AD7 -m \"commit message\" This is how the commit looks`: commit d89b296e9d58cc4281aeead172b170739acc164c (HEAD -> main) gpg: Signature made jue 12 may 2022 15:36:29 WEST gpg: using RSA key BD98B3F42545FF93EFF55F7F3F39AA1432CA6AD7 gpg: Good signature from \"A committer <committer@example.com>\" [ultimate] Author: Jose Celano <josecelano@gmail.com> AuthorDate: Thu May 12 15:36:29 2022 +0100 Commit: Jose Celano [bot] <bot@josecelano.com> CommitDate: Thu May 12 15:36:29 2022 +0100 commit message","title":"Commit signature in Git"},{"location":"010_GPG-Git-commits-partially-verified/#commit-signature-on-github","text":"That is how Git works, but GitHub does not work exactly like Git. On the GitHub Documentation you can read: Note: When asked to enter your email address, ensure that you enter the verified email address for your GitHub account. To keep your email address private, use your GitHub-provided no-reply email address. For more information, see \"Verifying your email address\" and \"Setting your commit email address.\" GitHub forces you to a use a GPG key whose user ID matches one of your GitHub account emails, so that when GitHub verified the signature not only verifies that the signature is OK but it also verifies that committer's email and account email match. You should only enable vigilant mode if you sign all of your commits and tags and use an email address that is verified for your account on GitHub as your committer email address. GitHub shows you a simplified version of Git. Because it links the GPG key to the committer. Although is not a Git constraint it is a common practice. GitLab seems to do exactly the same: For GitLab to consider a commit verified: The committer must have a GPG public/private key pair. The committer\u2019s public key must be uploaded to their GitLab account. One of the email addresses in the GPG public key must match a verified email address used by the committer in GitLab. To keep this address private, use the automatically generated private commit email address GitLab provides in your profile. The committer\u2019s email address must match the verified email address from the GPG key. For the rest of this article we assume that the GPG key fulfills the requirements in the GitLab documentation. We do not know if GitHub has exactly the same restrictions as we have not found documentation about it.","title":"Commit signature on GitHub"},{"location":"010_GPG-Git-commits-partially-verified/#git-commit-with-multiple-gpg-signatures","text":"Git does not allow to add more than one GPG signature to a commit. What Git does is generate the commit object and sign it with GPG. The signature is then added as a commit header . We have not found a reason why Git does not support multiple signatures. Since Git only relays on the GPG console command, we thought the reason was that GPG did not support it either, but as you can read on this Stackoverflow answer , there are two ways to add multiple signatures to a file using GPG. The first solution is to sign the contents with one key and sign the result again with the following key until you sign it with all the keys. The second solution would be using \"detached signatures\", which means the signature is not included in the signed document. We suppose Git could have used this approach, and this article from Owen Jacobson( describes it in detail. But it is not the case. Although Git uses \"detached signatures\", the signature is included as a commit header inside the \"full\" commit object that is used to calculate the commit hash. That means changing the signature changes the commit hash.","title":"Git commit with multiple GPG signatures"},{"location":"010_GPG-Git-commits-partially-verified/#git-merge-rebase-and-gpg-signature","text":"So, we know that Git does not allow including the author's signature and the committer's signature. We have the restriction that you can only add one signature to each commit. That means you will permanently lose the author's signature when you commit someone else's code. You could include the author's signature instead of the committer's one but that is not an standard practice. If you want to include the author's signature your can keep the original commit, for example, by using git merge (with a merge commit) to merge branches. We will see whether that is important or not, why it is crucial, and how you can deal with this problem. However, before that, we need to understand what happens when a committer specifies a different author and other cases where the author changes automatically. When you use the git rebase command with a different committer than the original commits, Git will keep the original author as the author of the newly generated commits. echo \"Initialize repo\" mkdir /tmp/git-test cd /tmp/git-test/ git init echo \"Add a file as maintainer\" touch a.txt git add -A GIT_COMMITTER_NAME=\"maintainer\" \\ GIT_COMMITTER_EMAIL=\"maintainer@email.com\" \\ GIT_AUTHOR_NAME=\"maintainer\" \\ GIT_AUTHOR_EMAIL=\"maintainer@email.com\" \\ git commit --no-gpg-sign -m \"add a.txt\" echo \"Add a file as contributor on a topic branch\" git checkout -b topic-branch touch b.txt git add -A GIT_COMMITTER_NAME=\"contributor\" \\ GIT_COMMITTER_EMAIL=\"contributor@email.com\" \\ GIT_AUTHOR_NAME=\"contributor\" \\ GIT_AUTHOR_EMAIL=\"contributor@email.com\" \\ git commit --no-gpg-sign -m \"add b.txt\" git show --pretty=fuller HEAD echo \"Add another file as maintainer on the main branch\" git checkout main touch c.txt git add -A GIT_COMMITTER_NAME=\"maintainer\" \\ GIT_COMMITTER_EMAIL=\"maintainer@email.com\" \\ GIT_AUTHOR_NAME=\"maintainer\" \\ GIT_AUTHOR_EMAIL=\"maintainer@email.com\" \\ git commit --no-gpg-sign -m \"add c.txt\" echo \"Rebase topic-branch as maintainer\" git checkout topic-branch GIT_COMMITTER_NAME=\"maintainer\" \\ GIT_COMMITTER_EMAIL=\"maintainer@email.com\" \\ GIT_AUTHOR_NAME=\"maintainer\" \\ GIT_AUTHOR_EMAIL=\"maintainer@email.com\" \\ git rebase main git log --pretty=fuller If you execute the script, you will see the original contributor commit: commit 148628f7f3f0f0a908ab5889e066eba842f4da66 (HEAD -> topic-branch) Author: contributor <contributor@email.com> AuthorDate: Mon May 2 15:43:09 2022 +0100 Commit: contributor <contributor@email.com> CommitDate: Mon May 2 15:43:09 2022 +0100 add b.txt And the commit after the rebase: commit 71f8feb30f8b02f26ddee67385152e25a774704f (HEAD -> topic-branch) Author: contributor <contributor@email.com> AuthorDate: Mon May 2 15:43:09 2022 +0100 Commit: maintainer <maintainer@email.com> CommitDate: Mon May 2 15:43:09 2022 +0100 add b.txt If you merge the topic-branch into the main branch with fast-forward: git checkout main GIT_COMMITTER_NAME=\"maintainer\" \\ GIT_COMMITTER_EMAIL=\"maintainer@email.com\" \\ git merge --ff-only topic-branch you will have the same commit 71f8feb30f8b02f26ddee67385152e25a774704f re-created by the maintainer in the main branch. git show --pretty=fuller HEAD commit 71f8feb30f8b02f26ddee67385152e25a774704f (HEAD -> main, topic-branch) Author: contributor <contributor@email.com> AuthorDate: Mon May 2 15:43:09 2022 +0100 Commit: maintainer <maintainer@email.com> CommitDate: Mon May 2 15:43:09 2022 +0100 add b.txt As you can see, Git keeps the author ( contributor <contributor@email.com> ) of the original commit. On the other hand, the maintainer could merge the topic-branch with a merge commit: echo \"Initialize repo\" mkdir /tmp/git-test cd /tmp/git-test/ git init echo \"Add a file as maintainer\" touch a.txt git add -A GIT_COMMITTER_NAME=\"maintainer\" \\ GIT_COMMITTER_EMAIL=\"maintainer@email.com\" \\ GIT_AUTHOR_NAME=\"maintainer\" \\ GIT_AUTHOR_EMAIL=\"maintainer@email.com\" \\ git commit --no-gpg-sign -m \"add a.txt\" echo \"Add a file as contributor on a topic branch\" git checkout -b topic-branch touch b.txt git add -A GIT_COMMITTER_NAME=\"contributor\" \\ GIT_COMMITTER_EMAIL=\"contributor@email.com\" \\ GIT_AUTHOR_NAME=\"contributor\" \\ GIT_AUTHOR_EMAIL=\"contributor@email.com\" \\ git commit --no-gpg-sign -m \"add b.txt\" git show --pretty=fuller HEAD echo \"Merge topic-branch as maintainer\" git checkout main GIT_COMMITTER_NAME=\"maintainer\" \\ GIT_COMMITTER_EMAIL=\"maintainer@email.com\" \\ GIT_AUTHOR_NAME=\"maintainer\" \\ GIT_AUTHOR_EMAIL=\"maintainer@email.com\" \\ git merge --no-ff topic-branch git log --pretty=fuller In this case, the contributor commit looks the same as in the previous example before rebasing: commit ac3b9f8eef024c30e59c01bce4943ad0597fab9c (HEAD -> topic-branch) Author: contributor <contributor@email.com> AuthorDate: Mon May 2 15:52:37 2022 +0100 Commit: contributor <contributor@email.com> CommitDate: Mon May 2 15:52:37 2022 +0100 add b.txt And after merging: commit 1b75bfb9d0b4621560bf2c6158e937ea457bb4e5 (HEAD -> main) Merge: 097e6ee ac3b9f8 Author: maintainer <maintainer@email.com> AuthorDate: Mon May 2 15:52:37 2022 +0100 Commit: maintainer <maintainer@email.com> CommitDate: Mon May 2 15:52:37 2022 +0100 Merge branch 'topic-branch' commit 097e6ee7f0088a54ec22712ce18fd08904d954b8 Author: maintainer <maintainer@email.com> AuthorDate: Mon May 2 15:52:37 2022 +0100 Commit: maintainer <maintainer@email.com> CommitDate: Mon May 2 15:52:37 2022 +0100 add a.txt commit ac3b9f8eef024c30e59c01bce4943ad0597fab9c (topic-branch) Author: contributor <contributor@email.com> AuthorDate: Mon May 2 15:52:37 2022 +0100 Commit: contributor <contributor@email.com> CommitDate: Mon May 2 15:52:37 2022 +0100 add b.txt You still have the original commit ac3b9f8eef024c30e59c01bce4943ad0597fab9c and the new merge commit 1b75bfb9d0b4621560bf2c6158e937ea457bb4e5 . Notice that you have to specify the author again for the git merge commit. Otherwise, the author would be your default committer info. For the git merge --ff-only topic-branch , you do not have to specify the author. Git uses the original commit author. NOTE: we could test what happens when the original commit has a different committer and author. We suppose the author is what is propagated, but we should check it with an example. If we were using GPG signatures, we would have only the committer signature on each final commit. NOTE: GitHub \"rebase and merge\" button does not work exactly as Git rebase . On GitHub documentation, you can read: \"The rebase and merge behavior on GitHub deviates slightly from Git rebase. Rebase and merge on GitHub will always update the committer information and create new commit SHAs, whereas Git rebase outside of GitHub does not change the committer information when the rebase happens on top of an ancestor commit. For more information about Git rebase, see git-rebase in the Git documentation.\" When it is possible to merge with fast-forward, Git will not change the original committer info. If you rerun the merge example using rebase with fast-forward: echo \"Initialize repo\" mkdir /tmp/git-test cd /tmp/git-test/ git init echo \"Add a file as maintainer\" touch a.txt git add -A GIT_COMMITTER_NAME=\"maintainer\" \\ GIT_COMMITTER_EMAIL=\"maintainer@email.com\" \\ GIT_AUTHOR_NAME=\"maintainer\" \\ GIT_AUTHOR_EMAIL=\"maintainer@email.com\" \\ git commit --no-gpg-sign -m \"add a.txt\" echo \"Add a file as contributor on a topic branch\" git checkout -b topic-branch touch b.txt git add -A GIT_COMMITTER_NAME=\"contributor\" \\ GIT_COMMITTER_EMAIL=\"contributor@email.com\" \\ GIT_AUTHOR_NAME=\"contributor\" \\ GIT_AUTHOR_EMAIL=\"contributor@email.com\" \\ git commit --no-gpg-sign -m \"add b.txt\" git show --pretty=fuller HEAD echo \"Merge topic-branch as maintainer\" git checkout main git merge --ff-only topic-branch git log --pretty=fuller The original contributor commits should be something like: commit d81c1a285a1a82fcdd8732ea159a58f66e082e1d (HEAD -> topic-branch) Author: contributor <contributor@email.com> AuthorDate: Mon May 2 16:22:28 2022 +0100 Commit: contributor <contributor@email.com> CommitDate: Mon May 2 16:22:28 2022 +0100 add b.txt And you can see the same commit after the merge: commit d81c1a285a1a82fcdd8732ea159a58f66e082e1d (HEAD -> main, topic-branch) Author: contributor <contributor@email.com> AuthorDate: Mon May 2 16:22:28 2022 +0100 Commit: contributor <contributor@email.com> CommitDate: Mon May 2 16:22:28 2022 +0100 add b.txt commit 176fa5d4b50bacc9e608d4cfad5957bd156da775 Author: maintainer <maintainer@email.com> AuthorDate: Mon May 2 16:22:28 2022 +0100 Commit: maintainer <maintainer@email.com> CommitDate: Mon May 2 16:22:28 2022 +0100 add a.txt That commit keeps the committer and author values. GitHub would override the committer info with the info of the logged-in user. GitHub does something like: git checkout main GIT_COMMITTER_NAME=\"maintainer\" \\ GIT_COMMITTER_EMAIL=\"maintainer@email.com\" \\ git merge --ff-only topic-branch More info on a GitHub blog post .","title":"Git merge, rebase and GPG signature"},{"location":"010_GPG-Git-commits-partially-verified/#how-to-keep-the-chain-of-trust","text":"Now we know: How Git uses the committer and author information. How Git deals with commit signatures. How GitHub works slightly different overwriting the committer info when you use the \"rebase and merge\" on a pull request. What happens when we create a new commit? When a new commit is created, we need to sign it again with the committer GPG key. That leads to two problems: We can lose the commit signature. We lose the author's signature. Let us start with point 1, having not signed commits. If we re-create new commits using rebase, we lose the original author signature, but we can add the maintainer one, as long as we do it in an environment where the GPG private key is available. For example, if you use the \"rebase and merge\" button provided by the GitHub UI, the new commit will not be signed because GitHub does not have the committer signing key. You can use a console command where the maintainer GPG private key is available. That forces you to stop using GitHub UI for merging pull requests if you want all your commits to be signed. Regarding point 2, losing the author's signature, we first must consider why we do not want to lose it. We can consider the signature a mechanism to review/accept changes. If we consider only the maintainers the final responsible for our code, losing the author's signature is not critical, as long as the maintainers make sure changes come from a trusted source. In this case, we are not breaking the trust. It is just that we trust maintainers, and they check signatures for other contributors they trust. The maintainers should ensure that commits on a pull request are signed by contributors they trust before merging them. On the other hand, It would be nice to keep that trust chain transparent so people using a package can check that third-party contributors' changes were accepted without changes. If you do not want to lose the author's signature, one obvious solution is to merge only using merge commits. It is out of the scope of this article to describe the pros and cons of losing or not losing the author's signature. A fascinating article by Mike Gerwitz explains the different alternatives in detail. When this happens on GitHub, you see this message on the commit status (if you have vigilant mode enabled): Maybe losing the author's signature is not an issue from the package user or the maintainers' point of view. However, from the author's point of view, you can not distinguish anymore between your legitimate commits and the fake ones. Someone else could pretend you have collaborated with their project. It is surprisingly easy to do that. You only need to create a commit and override the author with any users on GitHub.","title":"How to keep the chain of trust"},{"location":"010_GPG-Git-commits-partially-verified/#conclusion","text":"When you use signed commits: Be aware of the Git limitation of one single signature per commit. Be also aware of what happens to signatures when you use Git commands like \"merge\" and \"rebase\". Define your git branching/merging and release strategy according to your web of trust. Be prepared to stop using the GitHub UI and define your processes and scripts.","title":"Conclusion"},{"location":"010_GPG-Git-commits-partially-verified/#links","text":"Article by Mike Gerwitz: A Git Horror Story: Repository Integrity With Signed Commits Article by Owen Jacobson: Notes Towards Detached Signatures in Git Stackoverflow: Several GPG signatures for one file Stackoverflow: Git \u2013sign-off feature Hacker News: Git-signatures \u2013 Multiple PGP signatures for your commits Article by Micha\u0142 G\u00f3rny: Attack on git signature verification via crafting multiple signatures Git book: Git Tools - Signing Your Work Git docs: Git signature format Back to home","title":"Links"},{"location":"011_How-to-remove-commits-by-commit-message/","text":"Git - How to remove commits by their commit message Recently we had to remove a large number of commits from our repository. We have implemented a job queue as a GitHub Action. The queue is implemented using empty Git commits to store the jobs information. So you do not need external services. We call it Git-Queue . Since we were still using a beta version we decided to make some changes that broke compatibility with the old version. But we already had two demo repositories using the old version. In order to upgrade to the new version we have to remove thousands of commits related to the queue. Here you can read the original issue . All the queue commits have a prefix, so the Git history looks like: * 0830b3c2 - \ud83d\udcdd\u2705: library-update: job.id.1 job.ref.264657b51fbfcf63a0267fa425fd121f5f6781a0 (2022-06-13 10:43:37 +0000) <NautilusCyberneering[bot]> * 155125d8 - library aaa synced to commit 13db6c9f7c2f9ca7d8ae57b80cbbcc97a51a28a8 (2022-06-13 10:43:36 +0000) <A committer> * af02b696 - update library aaa to commit 13db6c9f7c2f9ca7d8ae57b80cbbcc97a51a28a8 (2022-06-13 10:43:33 +0000) <A committer> * 2b110030 - \ud83d\udcdd\ud83d\udc54: library-update: job.id.1 job.ref.264657b51fbfcf63a0267fa425fd121f5f6781a0 (2022-06-13 10:43:33 +0000) <NautilusCyberneering[bot]> * 264657b5 - \ud83d\udcdd\ud83c\ude3a: library-update: job.id.1 (2022-06-13 11:43:00 +0100) <NautilusCyberneering[bot]> We wanted to remove all commits with the prefix \ud83d\udcdd and also a different prefix we were using before that. After the first research we found a Stackoverflow question: Using git filter-branch to remove commits by their commit message There are a couple of solutions but both of them required to write a little bit of shell script. One of them uses git filter-branch but it seems that solution squashes the commits. That should not be a problem is our case because all the commits we wanted to delete are supposed to be empty. And we do not want to delete the commit changes. The other solution uses git rebase an a custom shell script to filter commits and mark them to \"drop\". Although those solutions were perfectly fine we decided to use reposurgeon which is a more powerful solution. Install reposurgeon If you are using Ubuntu I should be only: sudo apt-get install reposurgeon Reposurgeon has two modes: interactive and non-interactive. If you execute reposurgeon without any argument you could see something like: $ reposurgeon reposurgeon% help 6. The Command Interpreter 1. Command syntax syntax* 2. Finding your way around help, history, shell, quit 3. Regular Expressions regexp* 4. Selection syntax selection*, functions* 5. Redirection and shell-like features redirection* 7. Import and Export 1. Reading and writing repositories read, write 2. Repository type preference prefer, sourcetype 3. Rebuilds in place rebuild 5. File preservation preserve, unpreserve 6. Incorporating release tarballs incorporate 7. The repository list choose, drop, rename 8. Information and reports 1. Reports on the DAG list, index, names, stamp, tags, inspect, graph, lint, when 2. Statistics stats, count, sizes 3. Examining tree states manifest, checkout, diff 9. Surgical Operations 1. Commit deletion squash, delete 2. Commit mutation merge, unmerge, reparent, split, add, remove, tagify, reorder 3. Branches branch, branchlift, debranch 4. Tags, resets, and blobs tag, reset, blob, dedup 5. Repository splitting and merging divide, expunge, unite, graft 6. Metadata editing msgout, msgin, setfield, attribution, append, gitify, filter 7. Path reports and modifications path, setperm 8. Timequakes and time offsets timequake, timeoffset 9. Miscellanea renumber, transcode 10. Artifact handling 1. Attributions authors 2. Ignore patterns ignores 3. Reference lifting references, legacy 4. Changelogs changelogs 5. Clique coalescence coalesce 11. Control Options options*, set, clear 12. Scripting and debugging support 1. Variables, macros, and scripts assign, unassign, define, do, undefine, script, print 2. Housekeeping gc 3. Diagnostics log, logfile 4. Debugging resolve, version, hash, sizeof, strip 5. Profiling elapsed, timing, readlimit, memory, profile, exit Starred topics are not commands. reposurgeon% You can also create your own script and execute is later. The simplest think you can do is: reposurgeon \"read .\" lint ```s That command will execute to reposurgeon commands: 1. `read .`: it reads the current folder into memory. The current folder must be a repository. 2. `lint`: it checks the repository for errors. You can also enter is the interactive mode and execute both commands manually. Reposurgeon is a very big tool with a lot of options. You should read the basic documentation to understand how it works. Basically it imports any kind or repo and creates an internal representation of the repo. The you can execute some commands to change that representation and finally you can export again the internal representation into a different repo. One of the common tasks is used for is converting from different repositories formats. For example from [SNV](https://subversion.apache.org/) to [Git](https://git-scm.com/). We are going to explain only a use case here: how to remove commits that start with a given prefix. ## Removing commits that start with a given prefix Let's first create an empty repo: ```s mkdir /tmp/remove-commits-example cd /tmp/remove-commits-example git init Now we can add some commits. In order to simplify the example the commits we want to delete start with the prefix drop . echo \"hello world!\" > README.md git add . git commit -m \"add README\" git commit --allow-empty -m \"drop: empty commit\" After executing those command we will have two commits: * 9f606d6 - (HEAD -> main) drop: empty commit (2022-06-13 15:08:01 +0100) <Jose Celano> * 7533b82 - add README (2022-06-13 15:06:27 +0100) <Jose Celano> Now we want to remove the commit starting with drop . We can create a new file called: remove-commits.rs with this content: # Load the project into main memory read /tmp/remove-commits-example # Commit deletion /drop/c delete # We want to write a Git repository prefer git # Do it rebuild /tmp/new-remove-commits-example Then you can run the script with: reposurgeon \"script remove-commits.rs\" All the lines are self-explaining except maybe for the commit deletion one: /drop/c delete . The deletion command format is: {SELECTION} delete where SELECTION defines what you want to delete. That is very common for reposurgeon commands. The selection argument allows you to define which internal objects you want to act on. There are different types of selections. One of them it a \"text search\" which is a regular expression. A text search normally matches against the comment fields of commits and annotated tags, or against their author/committer names, or against the names of tags; also the text of passthrough objects. In our case the selection /drop/ means that we want to search for all objects containing the word drop . Since we allow want to delete commits, we can add what reposurgeon calls a \"qualifier letter\". The final command contains a c character after the regular expression: /drop/c . That changes the the scope of the search to only the comment text of commit or tag. After executing our script you can go to the newly generated repo and execute a git log command. You will see the commit starting with drop that was removed: cd new-remove-commits-example/ * 3d7da50 - (HEAD -> main) add README (2022-06-13 15:06:27 +0100) <Jose Celano> You can also notice that hte commit hash has for the remaining commit changed from 7533b82 to 3d7da50 . That means you have to force push the new repo version to the remote repo. Another side effect you might have is losing the commit signature. Links reposurgeon reposurgeon - commit deletion Back to home","title":"Git - How to remove commits by their commit message"},{"location":"011_How-to-remove-commits-by-commit-message/#git-how-to-remove-commits-by-their-commit-message","text":"Recently we had to remove a large number of commits from our repository. We have implemented a job queue as a GitHub Action. The queue is implemented using empty Git commits to store the jobs information. So you do not need external services. We call it Git-Queue . Since we were still using a beta version we decided to make some changes that broke compatibility with the old version. But we already had two demo repositories using the old version. In order to upgrade to the new version we have to remove thousands of commits related to the queue. Here you can read the original issue . All the queue commits have a prefix, so the Git history looks like: * 0830b3c2 - \ud83d\udcdd\u2705: library-update: job.id.1 job.ref.264657b51fbfcf63a0267fa425fd121f5f6781a0 (2022-06-13 10:43:37 +0000) <NautilusCyberneering[bot]> * 155125d8 - library aaa synced to commit 13db6c9f7c2f9ca7d8ae57b80cbbcc97a51a28a8 (2022-06-13 10:43:36 +0000) <A committer> * af02b696 - update library aaa to commit 13db6c9f7c2f9ca7d8ae57b80cbbcc97a51a28a8 (2022-06-13 10:43:33 +0000) <A committer> * 2b110030 - \ud83d\udcdd\ud83d\udc54: library-update: job.id.1 job.ref.264657b51fbfcf63a0267fa425fd121f5f6781a0 (2022-06-13 10:43:33 +0000) <NautilusCyberneering[bot]> * 264657b5 - \ud83d\udcdd\ud83c\ude3a: library-update: job.id.1 (2022-06-13 11:43:00 +0100) <NautilusCyberneering[bot]> We wanted to remove all commits with the prefix \ud83d\udcdd and also a different prefix we were using before that. After the first research we found a Stackoverflow question: Using git filter-branch to remove commits by their commit message There are a couple of solutions but both of them required to write a little bit of shell script. One of them uses git filter-branch but it seems that solution squashes the commits. That should not be a problem is our case because all the commits we wanted to delete are supposed to be empty. And we do not want to delete the commit changes. The other solution uses git rebase an a custom shell script to filter commits and mark them to \"drop\". Although those solutions were perfectly fine we decided to use reposurgeon which is a more powerful solution.","title":"Git - How to remove commits by their commit message"},{"location":"011_How-to-remove-commits-by-commit-message/#install-reposurgeon","text":"If you are using Ubuntu I should be only: sudo apt-get install reposurgeon Reposurgeon has two modes: interactive and non-interactive. If you execute reposurgeon without any argument you could see something like: $ reposurgeon reposurgeon% help 6. The Command Interpreter 1. Command syntax syntax* 2. Finding your way around help, history, shell, quit 3. Regular Expressions regexp* 4. Selection syntax selection*, functions* 5. Redirection and shell-like features redirection* 7. Import and Export 1. Reading and writing repositories read, write 2. Repository type preference prefer, sourcetype 3. Rebuilds in place rebuild 5. File preservation preserve, unpreserve 6. Incorporating release tarballs incorporate 7. The repository list choose, drop, rename 8. Information and reports 1. Reports on the DAG list, index, names, stamp, tags, inspect, graph, lint, when 2. Statistics stats, count, sizes 3. Examining tree states manifest, checkout, diff 9. Surgical Operations 1. Commit deletion squash, delete 2. Commit mutation merge, unmerge, reparent, split, add, remove, tagify, reorder 3. Branches branch, branchlift, debranch 4. Tags, resets, and blobs tag, reset, blob, dedup 5. Repository splitting and merging divide, expunge, unite, graft 6. Metadata editing msgout, msgin, setfield, attribution, append, gitify, filter 7. Path reports and modifications path, setperm 8. Timequakes and time offsets timequake, timeoffset 9. Miscellanea renumber, transcode 10. Artifact handling 1. Attributions authors 2. Ignore patterns ignores 3. Reference lifting references, legacy 4. Changelogs changelogs 5. Clique coalescence coalesce 11. Control Options options*, set, clear 12. Scripting and debugging support 1. Variables, macros, and scripts assign, unassign, define, do, undefine, script, print 2. Housekeeping gc 3. Diagnostics log, logfile 4. Debugging resolve, version, hash, sizeof, strip 5. Profiling elapsed, timing, readlimit, memory, profile, exit Starred topics are not commands. reposurgeon% You can also create your own script and execute is later. The simplest think you can do is: reposurgeon \"read .\" lint ```s That command will execute to reposurgeon commands: 1. `read .`: it reads the current folder into memory. The current folder must be a repository. 2. `lint`: it checks the repository for errors. You can also enter is the interactive mode and execute both commands manually. Reposurgeon is a very big tool with a lot of options. You should read the basic documentation to understand how it works. Basically it imports any kind or repo and creates an internal representation of the repo. The you can execute some commands to change that representation and finally you can export again the internal representation into a different repo. One of the common tasks is used for is converting from different repositories formats. For example from [SNV](https://subversion.apache.org/) to [Git](https://git-scm.com/). We are going to explain only a use case here: how to remove commits that start with a given prefix. ## Removing commits that start with a given prefix Let's first create an empty repo: ```s mkdir /tmp/remove-commits-example cd /tmp/remove-commits-example git init Now we can add some commits. In order to simplify the example the commits we want to delete start with the prefix drop . echo \"hello world!\" > README.md git add . git commit -m \"add README\" git commit --allow-empty -m \"drop: empty commit\" After executing those command we will have two commits: * 9f606d6 - (HEAD -> main) drop: empty commit (2022-06-13 15:08:01 +0100) <Jose Celano> * 7533b82 - add README (2022-06-13 15:06:27 +0100) <Jose Celano> Now we want to remove the commit starting with drop . We can create a new file called: remove-commits.rs with this content: # Load the project into main memory read /tmp/remove-commits-example # Commit deletion /drop/c delete # We want to write a Git repository prefer git # Do it rebuild /tmp/new-remove-commits-example Then you can run the script with: reposurgeon \"script remove-commits.rs\" All the lines are self-explaining except maybe for the commit deletion one: /drop/c delete . The deletion command format is: {SELECTION} delete where SELECTION defines what you want to delete. That is very common for reposurgeon commands. The selection argument allows you to define which internal objects you want to act on. There are different types of selections. One of them it a \"text search\" which is a regular expression. A text search normally matches against the comment fields of commits and annotated tags, or against their author/committer names, or against the names of tags; also the text of passthrough objects. In our case the selection /drop/ means that we want to search for all objects containing the word drop . Since we allow want to delete commits, we can add what reposurgeon calls a \"qualifier letter\". The final command contains a c character after the regular expression: /drop/c . That changes the the scope of the search to only the comment text of commit or tag. After executing our script you can go to the newly generated repo and execute a git log command. You will see the commit starting with drop that was removed: cd new-remove-commits-example/ * 3d7da50 - (HEAD -> main) add README (2022-06-13 15:06:27 +0100) <Jose Celano> You can also notice that hte commit hash has for the remaining commit changed from 7533b82 to 3d7da50 . That means you have to force push the new repo version to the remote repo. Another side effect you might have is losing the commit signature.","title":"Install reposurgeon"},{"location":"011_How-to-remove-commits-by-commit-message/#links","text":"reposurgeon reposurgeon - commit deletion Back to home","title":"Links"},{"location":"012_How-to-import-the-dependabot-gpg-public-key/","text":"How to import the dependabot GPG public-key THe GitHub dependabot is a GitHub dependency management tool that allows you to manage your dependencies in a way that is easy to use and easy to understand . The dependabot checks your dependencies regularly and if it finds any new dependencies it will automatically add them to your repository. This is a great way to keep your dependencies up to date and secure. The dependabot is a GitHub app that runs on your GitHub repository. It creates a new pull request to update your dependencies. It updates not only you language dependencies but also the action you use in your workflows. A commit from the dependabot looks like this: git show --show-signature 1ae99046a1e9da0de09cf02ec383a9433acf0665 commit 1ae99046a1e9da0de09cf02ec383a9433acf0665 gpg: Signature made mar 07 jun 2022 01:35:52 WEST gpg: using RSA key 4AEE18F83AFDEB23 gpg: Can't check signature: No public key Author: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com> Date: Tue Jun 7 00:35:52 2022 +0000 build(deps): bump actions/setup-node from 3.2.0 to 3.3.0 Bumps [actions/setup-node](https://github.com/actions/setup-node) from 3.2.0 to 3.3.0. - [Release notes](https://github.com/actions/setup-node/releases) - [Commits](https://github.com/actions/setup-node/compare/v3.2.0...v3.3.0) --- updated-dependencies: - dependency-name: actions/setup-node dependency-type: direct:production update-type: version-update:semver-minor ... Signed-off-by: dependabot[bot] <support@github.com> As you can see in the line gpg: Can't check signature: No public key , this is a GPG error that means that the dependabot's public GPG key is not installed on your machine. You can import the public key by executing this command: curl https://github.com/web-flow.gpg | gpg --import gpg -k 4AEE18F83AFDEB23 If you run the previous command again you will see the following output: git show --show-signature 1ae99046a1e9da0de09cf02ec383a9433acf0665 commit 1ae99046a1e9da0de09cf02ec383a9433acf0665 gpg: Signature made mar 07 jun 2022 01:35:52 WEST gpg: using RSA key 4AEE18F83AFDEB23 gpg: Good signature from \"GitHub (web-flow commit signing) <noreply@github.com>\" [unknown] gpg: WARNING: This key is not certified with a trusted signature! gpg: There is no indication that the signature belongs to the owner. Primary key fingerprint: 5DE3 E050 9C47 EA3C F04A 42D3 4AEE 18F8 3AFD EB23 Author: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com> Date: Tue Jun 7 00:35:52 2022 +0000 ... This time you see this message: gpg: Good signature from \"GitHub (web-flow commit signing) ... In order to remove that message you have to trust that key. $ gpg --edit-key 5DE3E0509C47EA3CF04A42D34AEE18F83AFDEB23 gpg (GnuPG) 2.2.20; Copyright (C) 2020 Free Software Foundation, Inc. This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. pub rsa2048/4AEE18F83AFDEB23 created: 2017-08-16 expires: never usage: SC trust: unknown validity: unknown [ unknown] (1). GitHub (web-flow commit signing) <noreply@github.com> gpg> trust pub rsa2048/4AEE18F83AFDEB23 created: 2017-08-16 expires: never usage: SC trust: unknown validity: unknown [ unknown] (1). GitHub (web-flow commit signing) <noreply@github.com> Please decide how far you trust this user to correctly verify other users' keys (by looking at passports, checking fingerprints from different sources, etc.) 1 = I don't know or won't say 2 = I do NOT trust 3 = I trust marginally 4 = I trust fully 5 = I trust ultimately m = back to the main menu Your decision? 5 Do you really want to set this key to ultimate trust? (y/N) y pub rsa2048/4AEE18F83AFDEB23 created: 2017-08-16 expires: never usage: SC trust: ultimate validity: unknown [ unknown] (1). GitHub (web-flow commit signing) <noreply@github.com> Please note that the shown key validity is not necessarily correct unless you restart the program. gpg> quit Finally, if you show the commit signature again you will see: $ git show --show-signature 1ae99046a1e9da0de09cf02ec383a9433acf0665 commit 1ae99046a1e9da0de09cf02ec383a9433acf0665 gpg: Signature made mar 07 jun 2022 01:35:52 WEST gpg: using RSA key 4AEE18F83AFDEB23 gpg: Good signature from \"GitHub (web-flow commit signing) <noreply@github.com>\" [ultimate] Author: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com> Date: Tue Jun 7 00:35:52 2022 +0000 ... If you want to know more about validating other keys on your public keyring you can read the GPG documentation . Links Validating other keys on your public keyring Back to home","title":"How to import the dependabot GPG public-key"},{"location":"012_How-to-import-the-dependabot-gpg-public-key/#how-to-import-the-dependabot-gpg-public-key","text":"THe GitHub dependabot is a GitHub dependency management tool that allows you to manage your dependencies in a way that is easy to use and easy to understand . The dependabot checks your dependencies regularly and if it finds any new dependencies it will automatically add them to your repository. This is a great way to keep your dependencies up to date and secure. The dependabot is a GitHub app that runs on your GitHub repository. It creates a new pull request to update your dependencies. It updates not only you language dependencies but also the action you use in your workflows. A commit from the dependabot looks like this: git show --show-signature 1ae99046a1e9da0de09cf02ec383a9433acf0665 commit 1ae99046a1e9da0de09cf02ec383a9433acf0665 gpg: Signature made mar 07 jun 2022 01:35:52 WEST gpg: using RSA key 4AEE18F83AFDEB23 gpg: Can't check signature: No public key Author: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com> Date: Tue Jun 7 00:35:52 2022 +0000 build(deps): bump actions/setup-node from 3.2.0 to 3.3.0 Bumps [actions/setup-node](https://github.com/actions/setup-node) from 3.2.0 to 3.3.0. - [Release notes](https://github.com/actions/setup-node/releases) - [Commits](https://github.com/actions/setup-node/compare/v3.2.0...v3.3.0) --- updated-dependencies: - dependency-name: actions/setup-node dependency-type: direct:production update-type: version-update:semver-minor ... Signed-off-by: dependabot[bot] <support@github.com> As you can see in the line gpg: Can't check signature: No public key , this is a GPG error that means that the dependabot's public GPG key is not installed on your machine. You can import the public key by executing this command: curl https://github.com/web-flow.gpg | gpg --import gpg -k 4AEE18F83AFDEB23 If you run the previous command again you will see the following output: git show --show-signature 1ae99046a1e9da0de09cf02ec383a9433acf0665 commit 1ae99046a1e9da0de09cf02ec383a9433acf0665 gpg: Signature made mar 07 jun 2022 01:35:52 WEST gpg: using RSA key 4AEE18F83AFDEB23 gpg: Good signature from \"GitHub (web-flow commit signing) <noreply@github.com>\" [unknown] gpg: WARNING: This key is not certified with a trusted signature! gpg: There is no indication that the signature belongs to the owner. Primary key fingerprint: 5DE3 E050 9C47 EA3C F04A 42D3 4AEE 18F8 3AFD EB23 Author: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com> Date: Tue Jun 7 00:35:52 2022 +0000 ... This time you see this message: gpg: Good signature from \"GitHub (web-flow commit signing) ... In order to remove that message you have to trust that key. $ gpg --edit-key 5DE3E0509C47EA3CF04A42D34AEE18F83AFDEB23 gpg (GnuPG) 2.2.20; Copyright (C) 2020 Free Software Foundation, Inc. This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. pub rsa2048/4AEE18F83AFDEB23 created: 2017-08-16 expires: never usage: SC trust: unknown validity: unknown [ unknown] (1). GitHub (web-flow commit signing) <noreply@github.com> gpg> trust pub rsa2048/4AEE18F83AFDEB23 created: 2017-08-16 expires: never usage: SC trust: unknown validity: unknown [ unknown] (1). GitHub (web-flow commit signing) <noreply@github.com> Please decide how far you trust this user to correctly verify other users' keys (by looking at passports, checking fingerprints from different sources, etc.) 1 = I don't know or won't say 2 = I do NOT trust 3 = I trust marginally 4 = I trust fully 5 = I trust ultimately m = back to the main menu Your decision? 5 Do you really want to set this key to ultimate trust? (y/N) y pub rsa2048/4AEE18F83AFDEB23 created: 2017-08-16 expires: never usage: SC trust: ultimate validity: unknown [ unknown] (1). GitHub (web-flow commit signing) <noreply@github.com> Please note that the shown key validity is not necessarily correct unless you restart the program. gpg> quit Finally, if you show the commit signature again you will see: $ git show --show-signature 1ae99046a1e9da0de09cf02ec383a9433acf0665 commit 1ae99046a1e9da0de09cf02ec383a9433acf0665 gpg: Signature made mar 07 jun 2022 01:35:52 WEST gpg: using RSA key 4AEE18F83AFDEB23 gpg: Good signature from \"GitHub (web-flow commit signing) <noreply@github.com>\" [ultimate] Author: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com> Date: Tue Jun 7 00:35:52 2022 +0000 ... If you want to know more about validating other keys on your public keyring you can read the GPG documentation .","title":"How to import the dependabot GPG public-key"},{"location":"012_How-to-import-the-dependabot-gpg-public-key/#links","text":"Validating other keys on your public keyring Back to home","title":"Links"},{"location":"013_How-github-actions-can-get-access-to-secrets/","text":"How GitHub Actions can get access to secrets You can find the source code for the examples in this repository . Example using an embedded docker action Example using an embedded TypeScript action Default permissions for GitHub token Good practices handling secrets Other questions Links Credits GitHub Actions has contexts . Contexts are data structures where GitHub stores the information needed by workflows. There is one special context called secrets context . That context contains your secrets and a special secret called GITHUB_TOKEN , automatically added by GitHub. The permissions of the GITHUB_TOKEN depend on your organization's default configuration for the token and the event that triggered the workflow. There are three ways to pass secrets to actions: Action inputs in the step . Arguments in the step . Only for docker actions. Environment variables . According to GitHub documentation, an action could have access to the GITHUB_TOKEN even if you do not explicitly pass the token in one of the previous ways. Important: An action can access the GITHUB_TOKEN through the github.token context even if the workflow does not explicitly pass the GITHUB_TOKEN to the action. As a good security practice, you should always make sure that actions only have the minimum access they require by limiting the permissions granted to the GITHUB_TOKEN . For more information, see \"Permissions for the GITHUB_TOKEN.\" You can read that message here . As far as we know that's only possible because the action can also get a secret from its action.yml configuration file. For example, in the GitHub actions/checkout@v2 action, you can pass the token as an implicit input, but if you do not pass it, the actions will take it from the context and set it as a default value. You can see how the default value is taken from the context . token: description: > ... default: ${{ github.token }} That is something not well documented. You can use contexts not only in the workflow yml files but also in the action.yml files. You do not have access to all contexts in all places. See this table to know what contexts are available and when. We have create a demo repository for this article with some examples to understand the GitHub Actions lifecycle. Example using an embedded docker action We have created an embedded docker action . Then we have added a workflow tu run the action . And finally, the action prints all the environment variables that it receives. The embedded docker action . The workflow using the action . The output of the action . This is the output: PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin HOSTNAME=ae6e9d0aeb16 GITHUB_GRAPHQL_URL=https://api.github.com/graphql GITHUB_REF_NAME=main GITHUB_REF_PROTECTED=false GITHUB_STEP_SUMMARY=/github/file_commands/step_summary_9f775e7c-222f-474c-af92-9e61206d7ce4 GITHUB_BASE_REF= GITHUB_SERVER_URL=https://github.com GITHUB_API_URL=https://api.github.com GITHUB_ACTION_REPOSITORY= RUNNER_ARCH=X64 RUNNER_WORKSPACE=/home/runner/work/github-actions-secrets GITHUB_ACTIONS=true GITHUB_JOB=print-env-vars GITHUB_REF=refs/heads/main GITHUB_ACTOR=josecelano GITHUB_ACTION=__self GITHUB_REPOSITORY_OWNER=Nautilus-Cyberneering GITHUB_HEAD_REF= GITHUB_WORKSPACE=/github/workspace GITHUB_PATH=/github/file_commands/add_path_9f775e7c-222f-474c-af92-9e61206d7ce4 RUNNER_OS=Linux RUNNER_TEMP=/home/runner/work/_temp GITHUB_REPOSITORY=Nautilus-Cyberneering/github-actions-secrets GITHUB_ACTION_REF= GITHUB_ENV=/github/file_commands/set_env_9f775e7c-222f-474c-af92-9e61206d7ce4 RUNNER_TOOL_CACHE=/opt/hostedtoolcache ACTIONS_RUNTIME_URL=https://pipelines.actions.githubusercontent.com/J2bBGbKRuIqd1wfytSShy42Isw56QMlCsoBc38NVOsni9X2pHC/ CI=true HOME=/github/home GITHUB_SHA=87de66d88ac9362ee029a768589d808f4fdad0a2 GITHUB_RUN_ID=2397754211 GITHUB_RUN_NUMBER=9 GITHUB_RUN_ATTEMPT=1 GITHUB_WORKFLOW=Print env vars in docker ACTIONS_RUNTIME_TOKEN=*** GITHUB_EVENT_NAME=push GITHUB_REF_TYPE=branch GITHUB_EVENT_PATH=/github/workflow/event.json RUNNER_NAME=Hosted Agent GITHUB_RETENTION_DAYS=90 ACTIONS_CACHE_URL=https://artifactcache.actions.githubusercontent.com/J2bBGbKRuIqd1wfytSShy42Isw56QMlCsoBc38NVOsni9X2pHC/ We added some secrets to the repo ans as you can see there are none of them including the GitHub token. Example using an embedded TypeScript action We have also create an embedded TypeScript action to print all the environment variables. This is the workflow output : / spell-checker: disable / CI=true PIPX_HOME=/opt/pipx DOTNET_NOLOGO=1 ImageVersion=20220605.1 GOROOT_1_17_X64=/opt/hostedtoolcache/go/1.17.11/x64 RUNNER_USER=runner JAVA_HOME_8_X64=/usr/lib/jvm/temurin-8-jdk-amd64 HOME=/home/runner SWIFT_PATH=/usr/share/swift/usr/bin DOTNET_MULTILEVEL_LOOKUP=0 DEPLOYMENT_BASEPATH=/opt/runner DEBIAN_FRONTEND=noninteractive CONDA=/usr/share/miniconda ANT_HOME=/usr/share/ant LANG=C.UTF-8 AZURE_EXTENSION_DIR=/opt/az/azcliextensions JAVA_HOME=/usr/lib/jvm/temurin-11-jdk-amd64 INVOCATION_ID=5d2ec45523744def866f5782b6bd2fd4 RUNNER_TOOL_CACHE=/opt/hostedtoolcache GRAALVM_11_ROOT=/usr/local/graalvm/graalvm-ce-java11-22.1.0 LEIN_JAR=/usr/local/lib/lein/self-installs/leiningen-2.9.8-standalone.jar ANDROID_NDK_HOME=/usr/local/lib/android/sdk/ndk-bundle USER=runner ImageOS=ubuntu20 POWERSHELL_DISTRIBUTION_CHANNEL=GitHub-Actions-ubuntu20 JAVA_HOME_17_X64=/usr/lib/jvm/temurin-17-jdk-amd64 GRADLE_HOME=/usr/share/gradle-7.4.2 VCPKG_INSTALLATION_ROOT=/usr/local/share/vcpkg BOOTSTRAP_HASKELL_NONINTERACTIVE=1 PIPX_BIN_DIR=/opt/pipx_bin RUNNER_TRACKING_ID=github_681ec59d-a26f-4c69-86a5-4b87f29a6f29 GOROOT_1_16_X64=/opt/hostedtoolcache/go/1.16.15/x64 GOROOT_1_18_X64=/opt/hostedtoolcache/go/1.18.3/x64 ANDROID_NDK_ROOT=/usr/local/lib/android/sdk/ndk-bundle SELENIUM_JAR_PATH=/usr/share/java/selenium-server.jar CHROME_BIN=/usr/bin/google-chrome AGENT_TOOLSDIRECTORY=/opt/hostedtoolcache ANDROID_SDK_ROOT=/usr/local/lib/android/sdk ACCEPT_EULA=Y JAVA_HOME_11_X64=/usr/lib/jvm/temurin-11-jdk-amd64 SGX_AESM_ADDR=1 ANDROID_NDK_LATEST_HOME=/usr/local/lib/android/sdk/ndk/24.0.8215888 GECKOWEBDRIVER=/usr/local/share/gecko_driver NVM_DIR=/home/runner/.nvm ANDROID_HOME=/usr/local/lib/android/sdk XDG_CONFIG_HOME=/home/runner/.config HOMEBREW_PREFIX=/home/linuxbrew/.linuxbrew RUNNER_PERFLOG=/home/runner/perflog HOMEBREW_NO_AUTO_UPDATE=1 JOURNAL_STREAM=8:22886 LEIN_HOME=/usr/local/lib/lein CHROMEWEBDRIVER=/usr/local/share/chrome_driver DOTNET_SKIP_FIRST_TIME_EXPERIENCE=1 PATH=/home/linuxbrew/.linuxbrew/bin:/home/linuxbrew/.linuxbrew/sbin:/home/runner/.local/bin:/opt/pipx_bin:/home/runner/.cargo/bin:/home/runner/.config/composer/vendor/bin:/usr/local/.ghcup/bin:/home/runner/.dotnet/tools:/snap/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin PERFLOG_LOCATION_SETTING=RUNNER_PERFLOG HOMEBREW_CELLAR=/home/linuxbrew/.linuxbrew/Cellar HOMEBREW_REPOSITORY=/home/linuxbrew/.linuxbrew/Homebrew GITHUB_ACTIONS=true HOMEBREW_CLEANUP_PERIODIC_FULL_DAYS=3650 GITHUB_JOB=print-env-vars GITHUB_REF=refs/heads/main GITHUB_SHA=21d8327fb47121b483af88dc8df2dcde235a1167 GITHUB_REPOSITORY=Nautilus-Cyberneering/github-actions-secrets GITHUB_REPOSITORY_OWNER=Nautilus-Cyberneering GITHUB_RUN_ID=2496310873 GITHUB_RUN_NUMBER=7 GITHUB_RETENTION_DAYS=90 GITHUB_RUN_ATTEMPT=1 GITHUB_ACTOR=josecelano GITHUB_WORKFLOW=Print env vars in TypeScript action GITHUB_HEAD_REF= GITHUB_BASE_REF= GITHUB_EVENT_NAME=push GITHUB_SERVER_URL=https://github.com GITHUB_API_URL=https://api.github.com GITHUB_GRAPHQL_URL=https://api.github.com/graphql GITHUB_REF_NAME=main GITHUB_REF_PROTECTED=false GITHUB_REF_TYPE=branch GITHUB_WORKSPACE=/home/runner/work/github-actions-secrets/github-actions-secrets GITHUB_ACTION=__self GITHUB_EVENT_PATH=/home/runner/work/_temp/_github_workflow/event.json GITHUB_ACTION_REPOSITORY= GITHUB_ACTION_REF= GITHUB_PATH=/home/runner/work/_temp/_runner_file_commands/add_path_b3b81f35-7f4b-4f9c-9d56-c2ad7b770fc5 GITHUB_ENV=/home/runner/work/_temp/_runner_file_commands/set_env_b3b81f35-7f4b-4f9c-9d56-c2ad7b770fc5 GITHUB_STEP_SUMMARY=/home/runner/work/_temp/_runner_file_commands/step_summary_b3b81f35-7f4b-4f9c-9d56-c2ad7b770fc5 RUNNER_OS=Linux RUNNER_ARCH=X64 RUNNER_NAME=GitHub Actions 3 RUNNER_TEMP=/home/runner/work/_temp RUNNER_WORKSPACE=/home/runner/work/github-actions-secrets ACTIONS_RUNTIME_URL=https://pipelines.actions.githubusercontent.com/J2bBGbKRuIqd1wfytSShy42Isw56QMlCsoBc38NVOsni9X2pHC/ ACTIONS_RUNTIME_TOKEN=*** ACTIONS_CACHE_URL=https://artifactcache.actions.githubusercontent.com/J2bBGbKRuIqd1wfytSShy42Isw56QMlCsoBc38NVOsni9X2pHC/ / spell-checker: enable / Default permissions for GitHub token The GITHUB_TOKEN secret is added automatically to all workflows executions. You can remove all the permissions. By default it has all the permissions you define at the organization level. You can set the default permissions for the organization or repository . WARNING: by default GITHUB_TOKEN has all the permissions! Good practices handling secrets Given that actions do not have direct access to secrets, the only way to give access to them is by explicitly passing them. But you have to be careful because there could ways to do that without you even knowing it. You can read here different ways to accidentally pass secrets to actions. For example, if you define an environment variable at the workflow level like this: env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} All the actions in your workflow will have access to the token. Some good practices proposed by Stephen Hosom are: Environments are a great way to isolate secrets. Combine environments with environment rules that dictate which branches that they can be accessed from for the best isolation of your secrets. As a general rule, try to use the lower scope for secrets: environment, repository, organization. Repository secrets can be useful for secrets that are used in nearly every or every job within the repository, but we don't recommend them for anything that has write on a system or read to sensitive information. Restricting write access where possible is GOOD. This isn't always possible, so there are mitigating controls you can use. Using a CODEOWNERS file prevents unauthorized edits to workflows. This isn't one size fits all. Some workflows can be triggered based on branches and won't require a request reviewer to approve. Restricting an environment to only run off of a specific branch is the biggest defense you have. This means that even if your workflow includes a write token and CODEOWNERS can be bypassed because the action can execute from a branch, it still won't have access to your secrets. And other things to consider: If you have a job linked to an environment you should act as if all actions in that job could have access to all the environment secrets. So do not mix actions with different levels of access to your secrets. Other questions Do actions only have have access to the secrets when you pass the secrets to them via inputs, arguments, environment vars or input default values in action.yml? Yes, they do. But the only secret accessible via default values in an action.yml is the GITHUB_TOKEN , all other secrets must be passed explicitly. The one exception is reusable workflows that can pass all secrets, rather than specifying individual ones using the secrets: inherit option: https://docs.github.com/en/actions/using-workflows/reusing-workflows#passing-inputs-and-secrets-to-a-reusable-workflow . Is there a way to completely disable the GITHUB_TOKEN in a workflow? No, there is not. Is there a way to completely disable access to secrets in a workflow? As you can see in this workflow example , even if you disable the permissions for the GITHUB_TOKEN you are still able to get the secrets because you get them from the context, not using the GITHUB_TOKEN . You can check any of the workflow executions . In the \"Setup Job\" you will find a line like this: GITHUB_TOKEN Permissions Metadata: read With the permissions assigned to the GITHUB_TOKEN . Are contexts stored on disk in the GitHub runners? As far as we know, they are not. But something we miss from the documentation it's a better explanation of the lifecycle of the runners and how it is the communication between GitHub and runners. We assume that the context for jobs is used only at the Github's servers. The secrets are shared with the runner only before executing a job and they are not stored on the disk. The documentation says the secrets are deleted from memory when the job is done. Although GitHub Actions scrubs secrets from memory that are not referenced in the workflow (or an included action), the GITHUB_TOKEN and any referenced secrets can be harvested by a determined attacker. It's best to assume that a malicious action has access to any secrets or information that the runner has for that a job - regardless of if the secrets are on disk or in memory. Actions are not sandboxed within a workflow job, the security boundary is only between jobs/runs. See accessing secrets . Links GitHub Course - Securing your workflows . Accessing GH context in actions . Original discussion about this article . Credits Thank to Constantin Bosse and Stephen Hosom who carefully review the original version of this article . Back to home","title":"How GitHub Actions can get access to secrets"},{"location":"013_How-github-actions-can-get-access-to-secrets/#how-github-actions-can-get-access-to-secrets","text":"You can find the source code for the examples in this repository . Example using an embedded docker action Example using an embedded TypeScript action Default permissions for GitHub token Good practices handling secrets Other questions Links Credits GitHub Actions has contexts . Contexts are data structures where GitHub stores the information needed by workflows. There is one special context called secrets context . That context contains your secrets and a special secret called GITHUB_TOKEN , automatically added by GitHub. The permissions of the GITHUB_TOKEN depend on your organization's default configuration for the token and the event that triggered the workflow. There are three ways to pass secrets to actions: Action inputs in the step . Arguments in the step . Only for docker actions. Environment variables . According to GitHub documentation, an action could have access to the GITHUB_TOKEN even if you do not explicitly pass the token in one of the previous ways. Important: An action can access the GITHUB_TOKEN through the github.token context even if the workflow does not explicitly pass the GITHUB_TOKEN to the action. As a good security practice, you should always make sure that actions only have the minimum access they require by limiting the permissions granted to the GITHUB_TOKEN . For more information, see \"Permissions for the GITHUB_TOKEN.\" You can read that message here . As far as we know that's only possible because the action can also get a secret from its action.yml configuration file. For example, in the GitHub actions/checkout@v2 action, you can pass the token as an implicit input, but if you do not pass it, the actions will take it from the context and set it as a default value. You can see how the default value is taken from the context . token: description: > ... default: ${{ github.token }} That is something not well documented. You can use contexts not only in the workflow yml files but also in the action.yml files. You do not have access to all contexts in all places. See this table to know what contexts are available and when. We have create a demo repository for this article with some examples to understand the GitHub Actions lifecycle.","title":"How GitHub Actions can get access to secrets"},{"location":"013_How-github-actions-can-get-access-to-secrets/#example-using-an-embedded-docker-action","text":"We have created an embedded docker action . Then we have added a workflow tu run the action . And finally, the action prints all the environment variables that it receives. The embedded docker action . The workflow using the action . The output of the action . This is the output: PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin HOSTNAME=ae6e9d0aeb16 GITHUB_GRAPHQL_URL=https://api.github.com/graphql GITHUB_REF_NAME=main GITHUB_REF_PROTECTED=false GITHUB_STEP_SUMMARY=/github/file_commands/step_summary_9f775e7c-222f-474c-af92-9e61206d7ce4 GITHUB_BASE_REF= GITHUB_SERVER_URL=https://github.com GITHUB_API_URL=https://api.github.com GITHUB_ACTION_REPOSITORY= RUNNER_ARCH=X64 RUNNER_WORKSPACE=/home/runner/work/github-actions-secrets GITHUB_ACTIONS=true GITHUB_JOB=print-env-vars GITHUB_REF=refs/heads/main GITHUB_ACTOR=josecelano GITHUB_ACTION=__self GITHUB_REPOSITORY_OWNER=Nautilus-Cyberneering GITHUB_HEAD_REF= GITHUB_WORKSPACE=/github/workspace GITHUB_PATH=/github/file_commands/add_path_9f775e7c-222f-474c-af92-9e61206d7ce4 RUNNER_OS=Linux RUNNER_TEMP=/home/runner/work/_temp GITHUB_REPOSITORY=Nautilus-Cyberneering/github-actions-secrets GITHUB_ACTION_REF= GITHUB_ENV=/github/file_commands/set_env_9f775e7c-222f-474c-af92-9e61206d7ce4 RUNNER_TOOL_CACHE=/opt/hostedtoolcache ACTIONS_RUNTIME_URL=https://pipelines.actions.githubusercontent.com/J2bBGbKRuIqd1wfytSShy42Isw56QMlCsoBc38NVOsni9X2pHC/ CI=true HOME=/github/home GITHUB_SHA=87de66d88ac9362ee029a768589d808f4fdad0a2 GITHUB_RUN_ID=2397754211 GITHUB_RUN_NUMBER=9 GITHUB_RUN_ATTEMPT=1 GITHUB_WORKFLOW=Print env vars in docker ACTIONS_RUNTIME_TOKEN=*** GITHUB_EVENT_NAME=push GITHUB_REF_TYPE=branch GITHUB_EVENT_PATH=/github/workflow/event.json RUNNER_NAME=Hosted Agent GITHUB_RETENTION_DAYS=90 ACTIONS_CACHE_URL=https://artifactcache.actions.githubusercontent.com/J2bBGbKRuIqd1wfytSShy42Isw56QMlCsoBc38NVOsni9X2pHC/ We added some secrets to the repo ans as you can see there are none of them including the GitHub token.","title":"Example using an embedded docker action"},{"location":"013_How-github-actions-can-get-access-to-secrets/#example-using-an-embedded-typescript-action","text":"We have also create an embedded TypeScript action to print all the environment variables. This is the workflow output : / spell-checker: disable / CI=true PIPX_HOME=/opt/pipx DOTNET_NOLOGO=1 ImageVersion=20220605.1 GOROOT_1_17_X64=/opt/hostedtoolcache/go/1.17.11/x64 RUNNER_USER=runner JAVA_HOME_8_X64=/usr/lib/jvm/temurin-8-jdk-amd64 HOME=/home/runner SWIFT_PATH=/usr/share/swift/usr/bin DOTNET_MULTILEVEL_LOOKUP=0 DEPLOYMENT_BASEPATH=/opt/runner DEBIAN_FRONTEND=noninteractive CONDA=/usr/share/miniconda ANT_HOME=/usr/share/ant LANG=C.UTF-8 AZURE_EXTENSION_DIR=/opt/az/azcliextensions JAVA_HOME=/usr/lib/jvm/temurin-11-jdk-amd64 INVOCATION_ID=5d2ec45523744def866f5782b6bd2fd4 RUNNER_TOOL_CACHE=/opt/hostedtoolcache GRAALVM_11_ROOT=/usr/local/graalvm/graalvm-ce-java11-22.1.0 LEIN_JAR=/usr/local/lib/lein/self-installs/leiningen-2.9.8-standalone.jar ANDROID_NDK_HOME=/usr/local/lib/android/sdk/ndk-bundle USER=runner ImageOS=ubuntu20 POWERSHELL_DISTRIBUTION_CHANNEL=GitHub-Actions-ubuntu20 JAVA_HOME_17_X64=/usr/lib/jvm/temurin-17-jdk-amd64 GRADLE_HOME=/usr/share/gradle-7.4.2 VCPKG_INSTALLATION_ROOT=/usr/local/share/vcpkg BOOTSTRAP_HASKELL_NONINTERACTIVE=1 PIPX_BIN_DIR=/opt/pipx_bin RUNNER_TRACKING_ID=github_681ec59d-a26f-4c69-86a5-4b87f29a6f29 GOROOT_1_16_X64=/opt/hostedtoolcache/go/1.16.15/x64 GOROOT_1_18_X64=/opt/hostedtoolcache/go/1.18.3/x64 ANDROID_NDK_ROOT=/usr/local/lib/android/sdk/ndk-bundle SELENIUM_JAR_PATH=/usr/share/java/selenium-server.jar CHROME_BIN=/usr/bin/google-chrome AGENT_TOOLSDIRECTORY=/opt/hostedtoolcache ANDROID_SDK_ROOT=/usr/local/lib/android/sdk ACCEPT_EULA=Y JAVA_HOME_11_X64=/usr/lib/jvm/temurin-11-jdk-amd64 SGX_AESM_ADDR=1 ANDROID_NDK_LATEST_HOME=/usr/local/lib/android/sdk/ndk/24.0.8215888 GECKOWEBDRIVER=/usr/local/share/gecko_driver NVM_DIR=/home/runner/.nvm ANDROID_HOME=/usr/local/lib/android/sdk XDG_CONFIG_HOME=/home/runner/.config HOMEBREW_PREFIX=/home/linuxbrew/.linuxbrew RUNNER_PERFLOG=/home/runner/perflog HOMEBREW_NO_AUTO_UPDATE=1 JOURNAL_STREAM=8:22886 LEIN_HOME=/usr/local/lib/lein CHROMEWEBDRIVER=/usr/local/share/chrome_driver DOTNET_SKIP_FIRST_TIME_EXPERIENCE=1 PATH=/home/linuxbrew/.linuxbrew/bin:/home/linuxbrew/.linuxbrew/sbin:/home/runner/.local/bin:/opt/pipx_bin:/home/runner/.cargo/bin:/home/runner/.config/composer/vendor/bin:/usr/local/.ghcup/bin:/home/runner/.dotnet/tools:/snap/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin PERFLOG_LOCATION_SETTING=RUNNER_PERFLOG HOMEBREW_CELLAR=/home/linuxbrew/.linuxbrew/Cellar HOMEBREW_REPOSITORY=/home/linuxbrew/.linuxbrew/Homebrew GITHUB_ACTIONS=true HOMEBREW_CLEANUP_PERIODIC_FULL_DAYS=3650 GITHUB_JOB=print-env-vars GITHUB_REF=refs/heads/main GITHUB_SHA=21d8327fb47121b483af88dc8df2dcde235a1167 GITHUB_REPOSITORY=Nautilus-Cyberneering/github-actions-secrets GITHUB_REPOSITORY_OWNER=Nautilus-Cyberneering GITHUB_RUN_ID=2496310873 GITHUB_RUN_NUMBER=7 GITHUB_RETENTION_DAYS=90 GITHUB_RUN_ATTEMPT=1 GITHUB_ACTOR=josecelano GITHUB_WORKFLOW=Print env vars in TypeScript action GITHUB_HEAD_REF= GITHUB_BASE_REF= GITHUB_EVENT_NAME=push GITHUB_SERVER_URL=https://github.com GITHUB_API_URL=https://api.github.com GITHUB_GRAPHQL_URL=https://api.github.com/graphql GITHUB_REF_NAME=main GITHUB_REF_PROTECTED=false GITHUB_REF_TYPE=branch GITHUB_WORKSPACE=/home/runner/work/github-actions-secrets/github-actions-secrets GITHUB_ACTION=__self GITHUB_EVENT_PATH=/home/runner/work/_temp/_github_workflow/event.json GITHUB_ACTION_REPOSITORY= GITHUB_ACTION_REF= GITHUB_PATH=/home/runner/work/_temp/_runner_file_commands/add_path_b3b81f35-7f4b-4f9c-9d56-c2ad7b770fc5 GITHUB_ENV=/home/runner/work/_temp/_runner_file_commands/set_env_b3b81f35-7f4b-4f9c-9d56-c2ad7b770fc5 GITHUB_STEP_SUMMARY=/home/runner/work/_temp/_runner_file_commands/step_summary_b3b81f35-7f4b-4f9c-9d56-c2ad7b770fc5 RUNNER_OS=Linux RUNNER_ARCH=X64 RUNNER_NAME=GitHub Actions 3 RUNNER_TEMP=/home/runner/work/_temp RUNNER_WORKSPACE=/home/runner/work/github-actions-secrets ACTIONS_RUNTIME_URL=https://pipelines.actions.githubusercontent.com/J2bBGbKRuIqd1wfytSShy42Isw56QMlCsoBc38NVOsni9X2pHC/ ACTIONS_RUNTIME_TOKEN=*** ACTIONS_CACHE_URL=https://artifactcache.actions.githubusercontent.com/J2bBGbKRuIqd1wfytSShy42Isw56QMlCsoBc38NVOsni9X2pHC/ / spell-checker: enable /","title":"Example using an embedded TypeScript action"},{"location":"013_How-github-actions-can-get-access-to-secrets/#default-permissions-for-github-token","text":"The GITHUB_TOKEN secret is added automatically to all workflows executions. You can remove all the permissions. By default it has all the permissions you define at the organization level. You can set the default permissions for the organization or repository . WARNING: by default GITHUB_TOKEN has all the permissions!","title":"Default permissions for GitHub token"},{"location":"013_How-github-actions-can-get-access-to-secrets/#good-practices-handling-secrets","text":"Given that actions do not have direct access to secrets, the only way to give access to them is by explicitly passing them. But you have to be careful because there could ways to do that without you even knowing it. You can read here different ways to accidentally pass secrets to actions. For example, if you define an environment variable at the workflow level like this: env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} All the actions in your workflow will have access to the token. Some good practices proposed by Stephen Hosom are: Environments are a great way to isolate secrets. Combine environments with environment rules that dictate which branches that they can be accessed from for the best isolation of your secrets. As a general rule, try to use the lower scope for secrets: environment, repository, organization. Repository secrets can be useful for secrets that are used in nearly every or every job within the repository, but we don't recommend them for anything that has write on a system or read to sensitive information. Restricting write access where possible is GOOD. This isn't always possible, so there are mitigating controls you can use. Using a CODEOWNERS file prevents unauthorized edits to workflows. This isn't one size fits all. Some workflows can be triggered based on branches and won't require a request reviewer to approve. Restricting an environment to only run off of a specific branch is the biggest defense you have. This means that even if your workflow includes a write token and CODEOWNERS can be bypassed because the action can execute from a branch, it still won't have access to your secrets. And other things to consider: If you have a job linked to an environment you should act as if all actions in that job could have access to all the environment secrets. So do not mix actions with different levels of access to your secrets.","title":"Good practices handling secrets"},{"location":"013_How-github-actions-can-get-access-to-secrets/#other-questions","text":"Do actions only have have access to the secrets when you pass the secrets to them via inputs, arguments, environment vars or input default values in action.yml? Yes, they do. But the only secret accessible via default values in an action.yml is the GITHUB_TOKEN , all other secrets must be passed explicitly. The one exception is reusable workflows that can pass all secrets, rather than specifying individual ones using the secrets: inherit option: https://docs.github.com/en/actions/using-workflows/reusing-workflows#passing-inputs-and-secrets-to-a-reusable-workflow . Is there a way to completely disable the GITHUB_TOKEN in a workflow? No, there is not. Is there a way to completely disable access to secrets in a workflow? As you can see in this workflow example , even if you disable the permissions for the GITHUB_TOKEN you are still able to get the secrets because you get them from the context, not using the GITHUB_TOKEN . You can check any of the workflow executions . In the \"Setup Job\" you will find a line like this: GITHUB_TOKEN Permissions Metadata: read With the permissions assigned to the GITHUB_TOKEN . Are contexts stored on disk in the GitHub runners? As far as we know, they are not. But something we miss from the documentation it's a better explanation of the lifecycle of the runners and how it is the communication between GitHub and runners. We assume that the context for jobs is used only at the Github's servers. The secrets are shared with the runner only before executing a job and they are not stored on the disk. The documentation says the secrets are deleted from memory when the job is done. Although GitHub Actions scrubs secrets from memory that are not referenced in the workflow (or an included action), the GITHUB_TOKEN and any referenced secrets can be harvested by a determined attacker. It's best to assume that a malicious action has access to any secrets or information that the runner has for that a job - regardless of if the secrets are on disk or in memory. Actions are not sandboxed within a workflow job, the security boundary is only between jobs/runs. See accessing secrets .","title":"Other questions"},{"location":"013_How-github-actions-can-get-access-to-secrets/#links","text":"GitHub Course - Securing your workflows . Accessing GH context in actions . Original discussion about this article .","title":"Links"},{"location":"013_How-github-actions-can-get-access-to-secrets/#credits","text":"Thank to Constantin Bosse and Stephen Hosom who carefully review the original version of this article . Back to home","title":"Credits"},{"location":"014_Sharing-GitHub-secrets-with-third-party-actions/","text":"GitHub Actions: sharing your secrets with third-party actions One of the main advantages with GitHub Actions is that you can easily reuse actions in your workflows. You only need to search for what you need on the marketplace . But it is also a big risk. When you start using third-party packages, you can easily get into a situation where you have to deal with a security issue. The more dependencies you have, the riskier it is. At least, you should make sure you trust the action provider. There is an even worse case when the action itself has a lot of dependencies. That is the case for Megalinter . MegaLinter is a \"tool for CI/CD workflows that analyzes consistency and quality\" . It has a lot of dependencies. When you use MegaLinter in your workflow you are sharing data not only with MegaLinter team but with hundreds of other teams with millions of lines of code. If you make a mistake and you share a secret with that action, your secrets will not be a secret anymore. That is why we have been wondering if the MegaLinter itself could be a security problem and what could be the safest way tu run it. Default installation for MegaLinter GitHub token permissions Setup the workflow with the minimum permissions Links Credits Default installation for MegaLinter Supposing you created a new organization on GitHub, and a new repository and you wanted to use MegaLinter. After installing it, it would have added a workflow with this step: - name: MegaLinter id: ml uses: megalinter/megalinter/flavors/documentation@v5 env: VALIDATE_ALL_CODEBASE: true GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} That means you are passing the GITHUB_TOKEN as an environment variable. MegaLinter is a docker action and it is called this way on the GitHub runners: /usr/bin/docker run --name megalintermegalinterdocumentationv5_b424a0 --label 08450d --workdir /github/workspace --rm -e VALIDATE_ALL_CODEBASE -e GITHUB_TOKEN -e HOME -e GITHUB_JOB -e GITHUB_REF -e GITHUB_SHA -e GITHUB_REPOSITORY -e GITHUB_REPOSITORY_OWNER -e GITHUB_RUN_ID -e GITHUB_RUN_NUMBER -e GITHUB_RETENTION_DAYS -e GITHUB_RUN_ATTEMPT -e GITHUB_ACTOR -e GITHUB_WORKFLOW -e GITHUB_HEAD_REF -e GITHUB_BASE_REF -e GITHUB_EVENT_NAME -e GITHUB_SERVER_URL -e GITHUB_API_URL -e GITHUB_GRAPHQL_URL -e GITHUB_REF_NAME -e GITHUB_REF_PROTECTED -e GITHUB_REF_TYPE -e GITHUB_WORKSPACE -e GITHUB_ACTION -e GITHUB_EVENT_PATH -e GITHUB_ACTION_REPOSITORY -e GITHUB_ACTION_REF -e GITHUB_PATH -e GITHUB_ENV -e GITHUB_STEP_SUMMARY -e RUNNER_OS -e RUNNER_ARCH -e RUNNER_NAME -e RUNNER_TOOL_CACHE -e RUNNER_TEMP -e RUNNER_WORKSPACE -e ACTIONS_RUNTIME_URL -e ACTIONS_RUNTIME_TOKEN -e ACTIONS_CACHE_URL -e GITHUB_ACTIONS=true -e CI=true -v \"/var/run/docker.sock\":\"/var/run/docker.sock\" -v \"/home/runner/work/_temp/_github_home\":\"/github/home\" -v \"/home/runner/work/_temp/_github_workflow\":\"/github/workflow\" -v \"/home/runner/work/_temp/_runner_file_commands\":\"/github/file_commands\" -v \"/home/runner/work/github-actions-secrets/github-actions-secrets\":\"/github/workspace\" megalinter/megalinter-documentation:v5 \"-v\" \"/var/run/docker.sock:/var/run/docker.sock:rw\" You can check it on any of the workflow executions in this repo . As you can see there is an environment variable -e GITHUB_TOKEN . MegaLinter has 97 packages at the moment. That means there are a lot of dependencies that have access to the GITHUB_TOKEN . GitHub token permissions The GITHUB_TOKEN is a GitHub Action Token Secret that is automatically generated and is used to authenticate the GitHub API. But, what could MegaLinter and its dependencies do with that token? Currently, the default permissions for all workflows in any organization are: permissions: actions: read|write checks: read|write contents: read|write deployments: read|write issues: read|write packages: read|write pull-requests: read|write repository-projects: read|write security-events: read|write statuses: read|write If you do not overwrite those permissions for the MegaLinter workflow, the MegalInter will have full write access to the API when the workflow is executed by a maintainer in a local branch. For forked repositories, GitHub automatically changes the permissions of the GITHUB_TOKEN to only \"read\". But you still have read access to all the data. In most cases, you probably do not need it. So with that default configuration, any of the MegaLinter packages could use the token to create a new branch, create or modify a new workflow and export all your secrets. Could the MegaLinter or any other action export the secrets without modifying a workflow? Given that the MegaLinter or in general any other third-party action you are suing has access to the GITHUB_TOKEN with \"contents: write\" permission, what could that action do? could the action export the secrets without modifying a workflow just using the token? The answer is No, it cannot. Even it the action has access to the GITHUB_TOKEN there is no way to directly get the secrets from the API. The only way to get the secrets is by modifying a workflow and export or print them. Fir instance, MegaLinter could release a new minor version of their package with malicious code. They could update one of the embedded packages in the docker image and that package could contain malicious code to obtain secrets using the GITHUB_TOKEN . Since you normally use a major version for the action megalinter/megalinter/flavors/documentation@v5 you would use the newer version on the next workflow execution. Actions cannot obtain the secrets (including GITHUB_TOKEN ) if you do not pass them explicitly. See the article How GitHub Actions can get access to secrets . If the action has access to the GITHUB_TOKEN because you explicitly pass it, it could modify a workflow to export the secrets. The basic security rule for GitHub Actions is: if you can modify a branch you can get all the secrets linked to that branch which includes not only environment secrets but also repository and organization secrets. Setup the workflow with the minimum permissions According to the Principle of least privilege , we should grant MegaLinter only the permissions it needs. Depending on whether you want MegalInter to create comments on your PRs or auto-fix things you might need to give extra permissions to it. There are some courses and articles explaining how to implement secure workflows with GitHub Actions. See the links below. Things you could do to make your GitHub organization more secure: Change the default token permissions for the organization. You can change the default permissions granted to the GITHUB_TOKEN to read-only. Remove all permissions on the workflow for the token. You can do it by adding the following to the .github/workflows/mega-linter.yml file: permissions: {} . Gran each workflow only the permissions it needs. Depending on what you want the MegaLinter to do you will need to grant some specific permissions. For example pull-requests: write if you want it to write comments on pull requests or contents: write if you want it to auto-fix your code and push the changes. As we mentioned before, the risky permission is contents: write . NOTICE: you do not even need to give contents: read permission to the GITHUB_TOKEN in order to checkout the code if the repo is a public repo. But, what happens if you want to give MegaLinter contents: write permission? is there a way to avoid giving access to those 97 packages to your secrets? Solution 1: Using CODEOWNERS configuration One of the solutions provided by GitHub is the CODEOWNERS file. If actions can only get secrets from arguments and we are only passing the GITHUB_TOKEN to the action, the only way to get the secrets is by modifying a workflow to export the secrets. The CODEOWNERS file allows the repo admins to specify who should review changes on certain files. You could configure a team that has access to the .\\github\\workflows directory but this would not work because: CODEOWNERS only works on pull requests. And in that case, contents: write permission is not granted anyway. We are talking about branches created on the same repo by developers who already have write access. Even if the file requires a review by the user, the user is allowed to modify and review those files. So there is no option to limit the write access to the workflow files. Solution 2: Using branch protection rules and environment secrets You could avoid using repository level secrets. If all your secrets are environment secrets the MegaLinter action would not have access to those secrets. Only the jobs linked to the environment could have access to those secrets. We think this is a good practice anyway because normally secrets are related to one environment. But in some cases, having a repository secret makes sense, so this solution is not possible always. As a general good practice you should try using the lowest scope possible for your secrets. Repository secrets can be useful for secrets that are used in nearly every or every job within the repository, but we don't recommend them for anything that has write on a system or read to sensitive information. Solution 3: Using a different repository to run MegaLinter If you want to run the MegaLinter, for example, on every push to the main branch, you could create a MegaLinter repository that has a workflow that runs MegaLinter for a different repo. It would be a kind of MegaLinter worker. Although it might work, it does not seem to be an easy solution, both to implement and use. Besides, the problem was we wanted to give MegaLinter write permissions to auto-fix and push errors and in this case, we still would need write access to the remote origin repo. Conclusion There is no way to give MegaLinter write permission without trusting its 97 packages not to steal your secrets. Either you disable write permissions and fix things manually or you stick to a concrete docker image (hash) and you review carefully all the package updates. Maybe the best approach is a combination of all the previous solutions adding branch protection rules and environment secrets. A CODEOWNERS file preventing Actions from both opening and approving a PR to modify Actions. A GITHUB_TOKEN with reduced privileges either by changing the defaults at the repository level or explicitly defining your required permissions at the workflow level. Environment protections isolating sensitive credentials from general purpose linters and unit test jobs. The MegaLiner could be run only for develop branch linked to develop environment without any sensitive secret. Even with that configuration if you are a maintainer and you run MegaLinter with the \"push\" event MegaLinter could get access the all secrets. So, you should: Disable the MegaLinter workflow for the push event. Try to always use PRs from forks even by maintainers. or: Disable auto-fix feature. Disabling auto-fix feature to avoid giving MegaLinter write access is not a big problem since you can run MegaLinter locally before pushing your changes. If you have an alternative solution, please do not hesitate to open a new discussion on this repo. You might argue that that's the same problem you have when you trust all your node dependencies. For example, you might be using some development dependencies on your tests. If you run tests when a developer pushes a new commit to the main branch, you are giving those dependencies access to those secrets. Maybe that's another example of things you could be doing wrongly. In general, we found the environment secrets solution to be the best solution. You should only use organization or repository secrets for secrets that could be potentially captured by third-party development tools. And use those secrets with your custom actions, actions you completely trust or actions you review. Links GitHub Course - Securing your workflows . Accessing GH context in actions . Original discussion about this article . Credits Thank to Constantin Bosse and Stephen Hosom who carefully review the original version of this article . Back to home","title":"GitHub Actions: sharing your secrets with third-party actions"},{"location":"014_Sharing-GitHub-secrets-with-third-party-actions/#github-actions-sharing-your-secrets-with-third-party-actions","text":"One of the main advantages with GitHub Actions is that you can easily reuse actions in your workflows. You only need to search for what you need on the marketplace . But it is also a big risk. When you start using third-party packages, you can easily get into a situation where you have to deal with a security issue. The more dependencies you have, the riskier it is. At least, you should make sure you trust the action provider. There is an even worse case when the action itself has a lot of dependencies. That is the case for Megalinter . MegaLinter is a \"tool for CI/CD workflows that analyzes consistency and quality\" . It has a lot of dependencies. When you use MegaLinter in your workflow you are sharing data not only with MegaLinter team but with hundreds of other teams with millions of lines of code. If you make a mistake and you share a secret with that action, your secrets will not be a secret anymore. That is why we have been wondering if the MegaLinter itself could be a security problem and what could be the safest way tu run it. Default installation for MegaLinter GitHub token permissions Setup the workflow with the minimum permissions Links Credits","title":"GitHub Actions: sharing your secrets with third-party actions"},{"location":"014_Sharing-GitHub-secrets-with-third-party-actions/#default-installation-for-megalinter","text":"Supposing you created a new organization on GitHub, and a new repository and you wanted to use MegaLinter. After installing it, it would have added a workflow with this step: - name: MegaLinter id: ml uses: megalinter/megalinter/flavors/documentation@v5 env: VALIDATE_ALL_CODEBASE: true GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} That means you are passing the GITHUB_TOKEN as an environment variable. MegaLinter is a docker action and it is called this way on the GitHub runners: /usr/bin/docker run --name megalintermegalinterdocumentationv5_b424a0 --label 08450d --workdir /github/workspace --rm -e VALIDATE_ALL_CODEBASE -e GITHUB_TOKEN -e HOME -e GITHUB_JOB -e GITHUB_REF -e GITHUB_SHA -e GITHUB_REPOSITORY -e GITHUB_REPOSITORY_OWNER -e GITHUB_RUN_ID -e GITHUB_RUN_NUMBER -e GITHUB_RETENTION_DAYS -e GITHUB_RUN_ATTEMPT -e GITHUB_ACTOR -e GITHUB_WORKFLOW -e GITHUB_HEAD_REF -e GITHUB_BASE_REF -e GITHUB_EVENT_NAME -e GITHUB_SERVER_URL -e GITHUB_API_URL -e GITHUB_GRAPHQL_URL -e GITHUB_REF_NAME -e GITHUB_REF_PROTECTED -e GITHUB_REF_TYPE -e GITHUB_WORKSPACE -e GITHUB_ACTION -e GITHUB_EVENT_PATH -e GITHUB_ACTION_REPOSITORY -e GITHUB_ACTION_REF -e GITHUB_PATH -e GITHUB_ENV -e GITHUB_STEP_SUMMARY -e RUNNER_OS -e RUNNER_ARCH -e RUNNER_NAME -e RUNNER_TOOL_CACHE -e RUNNER_TEMP -e RUNNER_WORKSPACE -e ACTIONS_RUNTIME_URL -e ACTIONS_RUNTIME_TOKEN -e ACTIONS_CACHE_URL -e GITHUB_ACTIONS=true -e CI=true -v \"/var/run/docker.sock\":\"/var/run/docker.sock\" -v \"/home/runner/work/_temp/_github_home\":\"/github/home\" -v \"/home/runner/work/_temp/_github_workflow\":\"/github/workflow\" -v \"/home/runner/work/_temp/_runner_file_commands\":\"/github/file_commands\" -v \"/home/runner/work/github-actions-secrets/github-actions-secrets\":\"/github/workspace\" megalinter/megalinter-documentation:v5 \"-v\" \"/var/run/docker.sock:/var/run/docker.sock:rw\" You can check it on any of the workflow executions in this repo . As you can see there is an environment variable -e GITHUB_TOKEN . MegaLinter has 97 packages at the moment. That means there are a lot of dependencies that have access to the GITHUB_TOKEN .","title":"Default installation for MegaLinter"},{"location":"014_Sharing-GitHub-secrets-with-third-party-actions/#github-token-permissions","text":"The GITHUB_TOKEN is a GitHub Action Token Secret that is automatically generated and is used to authenticate the GitHub API. But, what could MegaLinter and its dependencies do with that token? Currently, the default permissions for all workflows in any organization are: permissions: actions: read|write checks: read|write contents: read|write deployments: read|write issues: read|write packages: read|write pull-requests: read|write repository-projects: read|write security-events: read|write statuses: read|write If you do not overwrite those permissions for the MegaLinter workflow, the MegalInter will have full write access to the API when the workflow is executed by a maintainer in a local branch. For forked repositories, GitHub automatically changes the permissions of the GITHUB_TOKEN to only \"read\". But you still have read access to all the data. In most cases, you probably do not need it. So with that default configuration, any of the MegaLinter packages could use the token to create a new branch, create or modify a new workflow and export all your secrets. Could the MegaLinter or any other action export the secrets without modifying a workflow? Given that the MegaLinter or in general any other third-party action you are suing has access to the GITHUB_TOKEN with \"contents: write\" permission, what could that action do? could the action export the secrets without modifying a workflow just using the token? The answer is No, it cannot. Even it the action has access to the GITHUB_TOKEN there is no way to directly get the secrets from the API. The only way to get the secrets is by modifying a workflow and export or print them. Fir instance, MegaLinter could release a new minor version of their package with malicious code. They could update one of the embedded packages in the docker image and that package could contain malicious code to obtain secrets using the GITHUB_TOKEN . Since you normally use a major version for the action megalinter/megalinter/flavors/documentation@v5 you would use the newer version on the next workflow execution. Actions cannot obtain the secrets (including GITHUB_TOKEN ) if you do not pass them explicitly. See the article How GitHub Actions can get access to secrets . If the action has access to the GITHUB_TOKEN because you explicitly pass it, it could modify a workflow to export the secrets. The basic security rule for GitHub Actions is: if you can modify a branch you can get all the secrets linked to that branch which includes not only environment secrets but also repository and organization secrets.","title":"GitHub token permissions"},{"location":"014_Sharing-GitHub-secrets-with-third-party-actions/#setup-the-workflow-with-the-minimum-permissions","text":"According to the Principle of least privilege , we should grant MegaLinter only the permissions it needs. Depending on whether you want MegalInter to create comments on your PRs or auto-fix things you might need to give extra permissions to it. There are some courses and articles explaining how to implement secure workflows with GitHub Actions. See the links below. Things you could do to make your GitHub organization more secure: Change the default token permissions for the organization. You can change the default permissions granted to the GITHUB_TOKEN to read-only. Remove all permissions on the workflow for the token. You can do it by adding the following to the .github/workflows/mega-linter.yml file: permissions: {} . Gran each workflow only the permissions it needs. Depending on what you want the MegaLinter to do you will need to grant some specific permissions. For example pull-requests: write if you want it to write comments on pull requests or contents: write if you want it to auto-fix your code and push the changes. As we mentioned before, the risky permission is contents: write . NOTICE: you do not even need to give contents: read permission to the GITHUB_TOKEN in order to checkout the code if the repo is a public repo. But, what happens if you want to give MegaLinter contents: write permission? is there a way to avoid giving access to those 97 packages to your secrets?","title":"Setup the workflow with the minimum permissions"},{"location":"014_Sharing-GitHub-secrets-with-third-party-actions/#solution-1-using-codeowners-configuration","text":"One of the solutions provided by GitHub is the CODEOWNERS file. If actions can only get secrets from arguments and we are only passing the GITHUB_TOKEN to the action, the only way to get the secrets is by modifying a workflow to export the secrets. The CODEOWNERS file allows the repo admins to specify who should review changes on certain files. You could configure a team that has access to the .\\github\\workflows directory but this would not work because: CODEOWNERS only works on pull requests. And in that case, contents: write permission is not granted anyway. We are talking about branches created on the same repo by developers who already have write access. Even if the file requires a review by the user, the user is allowed to modify and review those files. So there is no option to limit the write access to the workflow files.","title":"Solution 1: Using CODEOWNERS configuration"},{"location":"014_Sharing-GitHub-secrets-with-third-party-actions/#solution-2-using-branch-protection-rules-and-environment-secrets","text":"You could avoid using repository level secrets. If all your secrets are environment secrets the MegaLinter action would not have access to those secrets. Only the jobs linked to the environment could have access to those secrets. We think this is a good practice anyway because normally secrets are related to one environment. But in some cases, having a repository secret makes sense, so this solution is not possible always. As a general good practice you should try using the lowest scope possible for your secrets. Repository secrets can be useful for secrets that are used in nearly every or every job within the repository, but we don't recommend them for anything that has write on a system or read to sensitive information.","title":"Solution 2: Using branch protection rules and environment secrets"},{"location":"014_Sharing-GitHub-secrets-with-third-party-actions/#solution-3-using-a-different-repository-to-run-megalinter","text":"If you want to run the MegaLinter, for example, on every push to the main branch, you could create a MegaLinter repository that has a workflow that runs MegaLinter for a different repo. It would be a kind of MegaLinter worker. Although it might work, it does not seem to be an easy solution, both to implement and use. Besides, the problem was we wanted to give MegaLinter write permissions to auto-fix and push errors and in this case, we still would need write access to the remote origin repo.","title":"Solution 3: Using a different repository to run MegaLinter"},{"location":"014_Sharing-GitHub-secrets-with-third-party-actions/#conclusion","text":"There is no way to give MegaLinter write permission without trusting its 97 packages not to steal your secrets. Either you disable write permissions and fix things manually or you stick to a concrete docker image (hash) and you review carefully all the package updates. Maybe the best approach is a combination of all the previous solutions adding branch protection rules and environment secrets. A CODEOWNERS file preventing Actions from both opening and approving a PR to modify Actions. A GITHUB_TOKEN with reduced privileges either by changing the defaults at the repository level or explicitly defining your required permissions at the workflow level. Environment protections isolating sensitive credentials from general purpose linters and unit test jobs. The MegaLiner could be run only for develop branch linked to develop environment without any sensitive secret. Even with that configuration if you are a maintainer and you run MegaLinter with the \"push\" event MegaLinter could get access the all secrets. So, you should: Disable the MegaLinter workflow for the push event. Try to always use PRs from forks even by maintainers. or: Disable auto-fix feature. Disabling auto-fix feature to avoid giving MegaLinter write access is not a big problem since you can run MegaLinter locally before pushing your changes. If you have an alternative solution, please do not hesitate to open a new discussion on this repo. You might argue that that's the same problem you have when you trust all your node dependencies. For example, you might be using some development dependencies on your tests. If you run tests when a developer pushes a new commit to the main branch, you are giving those dependencies access to those secrets. Maybe that's another example of things you could be doing wrongly. In general, we found the environment secrets solution to be the best solution. You should only use organization or repository secrets for secrets that could be potentially captured by third-party development tools. And use those secrets with your custom actions, actions you completely trust or actions you review.","title":"Conclusion"},{"location":"014_Sharing-GitHub-secrets-with-third-party-actions/#links","text":"GitHub Course - Securing your workflows . Accessing GH context in actions . Original discussion about this article .","title":"Links"},{"location":"014_Sharing-GitHub-secrets-with-third-party-actions/#credits","text":"Thank to Constantin Bosse and Stephen Hosom who carefully review the original version of this article . Back to home","title":"Credits"},{"location":"015_How-to-use-Git-as-a-database/","text":"Using Git as a key-value database Obviously you can store whatever you want in a Git repository but in this article we will see how to use the Git internal data structures to store and retrieve data. Where to store things Using Git Objects Using Git References Store only the latest state Store state change history How to solve race conditions Optimistic concurrency control Atomic Git push GitHub Git database Links Projects using Git objects and references to store data Talks Articles Books Where to store things? With Git you can store data in two different ways: Git objects References Those are the two ways Git stores data internally. Using Git Objects Git internally uses a key-value database with only 4 types of objects : blobs , trees , commits and annotated tags . Each object is stored in the database and the way to reference the object is by using its sha1 (a checksum of the content). For example, you can insert a new object in the database with: cd /tmp mkdir test cd test git init echo 'test content' | git hash-object -w --stdin d670460b4b4aece5915caf5c68d12f560a9fe3e4 The last command output is the sha1 of the new object. You can get the object content back using that sha1: git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4 This database is immutable. You can only add new content. If you are curious where Git stores those objects you can run this command: $ tree .git/ .git/ \u251c\u2500\u2500 branches \u251c\u2500\u2500 config \u251c\u2500\u2500 description \u251c\u2500\u2500 HEAD \u251c\u2500\u2500 hooks \u2502 \u251c\u2500\u2500 applypatch-msg.sample \u2502 \u251c\u2500\u2500 commit-msg.sample \u2502 \u251c\u2500\u2500 fsmonitor-watchman.sample \u2502 \u251c\u2500\u2500 post-update.sample \u2502 \u251c\u2500\u2500 pre-applypatch.sample \u2502 \u251c\u2500\u2500 pre-commit.sample \u2502 \u251c\u2500\u2500 pre-merge-commit.sample \u2502 \u251c\u2500\u2500 prepare-commit-msg.sample \u2502 \u251c\u2500\u2500 pre-push.sample \u2502 \u251c\u2500\u2500 pre-rebase.sample \u2502 \u251c\u2500\u2500 pre-receive.sample \u2502 \u251c\u2500\u2500 push-to-checkout.sample \u2502 \u2514\u2500\u2500 update.sample \u251c\u2500\u2500 info \u2502 \u2514\u2500\u2500 exclude \u251c\u2500\u2500 objects \u2502 \u251c\u2500\u2500 d6 \u2502 \u2502 \u2514\u2500\u2500 70460b4b4aece5915caf5c68d12f560a9fe3e4 \u2502 \u251c\u2500\u2500 info \u2502 \u2514\u2500\u2500 pack \u2514\u2500\u2500 refs \u251c\u2500\u2500 heads \u2514\u2500\u2500 tags 10 directories, 18 files You can see the file .git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 . There it is where Git stores the object. Using Git References Git has a directory .git/refs which contains files that are the references . Each file contains a sha1 of a database object. That means references are lia alias for objects. They allow you to reference objects in the database with a more readable name. If you want to get the content from the previous example but do not want to use the sha1, you could create a reference like this: git update-ref refs/my-objects/object-1 d670460b4b4aece5915caf5c68d12f560a9fe3e4 The reference is a pointer or alias for the object hash you have inserted in the database before. And now you can use the reference to get the content: $ git cat-file -p refs/my-objects/object-1 test content NOTICE: we are using a custom reference name. You can use any name and path you want. This database is a mutable database. You can change references to point to different Git objects. You can create new references in any fork of the repository and push them to any remote repository. There are some special references handled by Git: $ tree -al .git/refs/ .git/refs/ \u251c\u2500\u2500 heads \u251c\u2500\u2500 my-objects \u2502 \u2514\u2500\u2500 object-1 \u2514\u2500\u2500 tags 3 directories, 1 file Branches consist only on references pointing to the latest commit object hash in a sequence of commits. When you run a git push command Git tries to update a reference in a remote repository. Git provides only those basic low-level databases to store things: objects and references . You can use them in different ways. We have seen at least two different models: Store only the latest state. Store state change history (commits). Store only the latest state You can store your data inside blob objects. When you want to update the version of your object you can store a new object. You can use a reference to retrieve the blob object. You also need to prevent the Git Garbage Collector from removing the object. If the blob object is not referenced anywhere it could be deleted. Thi diagram shows how to different processes can write objects: Pros: It is very simple. You only need to use two low level Git commits to store and retrieve your data and the very well-known porcelain commands to move data between repositories: pull and push . Cons: You cannot checkout the reference because it does not point to a commit. $ git checkout refs/my-objects/object-1 fatal: reference is not a tree: refs/my-objects/object-1 You cannot follow changes on the object because each new object version is not linked to the previous one. It is like a standard database. If you want to keep a history of your changes you can do it by yourself or use the next model. The model generates a lot of references since we need a reference for each object. Store state change history The previous solution allows you to store objects like a key-value database. But you can take full advantage of Git by using the other available objects. When you update a blob object you could create a commit. cd /tmp mkdir test cd test git init git checkout --orphan \"my-objects-object-1\" echo \"test content\" > object-1.txt git add . git commit --no-gpg-sign -m \"add object-1.txt\" You can get the object with: git checkout my-objects-object-1 && cat object-1.txt But actually the object value is accessible directly just like an standard file. All you need to do is checkout the reference (the branch) we are using to store the object. git checkout my-objects-object-1 && cat object-1.txt $ tree -al .git/refs/ .git/refs/ \u251c\u2500\u2500 heads \u2502 \u2514\u2500\u2500 my-objects-object-1 \u2514\u2500\u2500 tags Pros: You can add metadata for every database operation in the commit message. You can easily get the data using the Git Porcelain commands. You have the history of changes for your objects. Cons: It is more complex than the previous solution. It generates a lot of references too. One per object. This model uses an orphan branch for each object. An \"orphan\" branch is a branch that is not connected to any other branch. That means the first commit does not have any ancestors. How to solve race conditions We have seen two possible models to use Git to store your data as a key-value database. But does this database implementation offer you a way to handle race conditions? At some point, you are going to have two processes reading the same object and trying to update it at the same time. One of them is going to overwrite a previous value. We can create an example where we have a \u201ctable\u201d with counters. We insert the first object with a counter starting at 0. cd /tmp mkdir my-counters cd my-counters/ git init git checkout -b my-counters-counter-1 echo \"0\" > counter-1.txt git add . git commit --no-gpg-sign -m \"initialize counter-1\" cat counter-1.txt An independent processes could checkout the repository and increment the counter. After cloning the repository you have an old version of the data because other processes could have cloned and updated the counter. Git is a decentralized data structure and the only way to reconciliate things is by using pull and push commands. Git will tell you when you are trying to merge data with conflicts. Optimistic concurrency control We normally have two options to fix that problem with normal databases, you can either lock the record when you want to modify it (pessimistic locking) or try to modify it always and make the update fail if the record has changed (optimistic locking). Git only allows us to use the optimistic approach . When you try to \u201cpush\u201d your object version by updating the reference in the origin repo you will get an error if the reference (branch) was already changed. We can reproduce the conflict in our previous example. We are going to clone the repository twice in two different folders. cd /tmp git clone /tmp/my-counters my-counters-process-1 cd /tmp/my-counters-process-1/ git checkout my-counters-counter-1 cat counter-1.txt cd /tmp git clone /tmp/my-counters my-counters-process-2 cd /tmp/my-counters-process-2/ git checkout my-counters-counter-1 cat counter-1.txt The last output line should show the value 0 for the counter-1 . Now we can increment the counter with the first process and push the new value. cd /tmp/my-counters-process-1 git checkout my-counters-counter-1 echo \"1\" > counter-1.txt git add . git commit --no-gpg-sign -m \"increment counter-1 to 1\" echo \"2\" > counter-1.txt git add . git commit --no-gpg-sign -m \"increment counter-1 to 2\" cat counter-1.txt If you try to push the counter you are going to have this error: git push origin \u2026 ! [remote rejected] counter-1 -> counter-1 (branch is currently checked out) error: failed to push some refs to '/tmp/my-counters' That is because you are on the same branch in the origin repository. You only need to checkout a different branch in the origin repo. cd /tmp/my-counters git checkout --orphan another-branch Got bak to the process-1 folder and push the new value. cd /tmp/my-counters-process-1/ git push origin Now, the output should be like: Enumerating objects: 8, done. Counting objects: 100% (8/8), done. Delta compression using up to 8 threads Compressing objects: 100% (2/2), done. Writing objects: 100% (6/6), 482 bytes | 482.00 KiB/s, done. Total 6 (delta 0), reused 0 (delta 0), pack-reused 0 To /tmp/my-counters 7614015..ba3cbfb my-counters-counter-1 -> my-counters-counter-1 You have updated the origin (our database) with a new value. Now, if you try to push changes from the process-2 : cd /tmp/my-counters-process-2 git checkout my-counters-counter-1 echo \"1\" > counter-1.txt git add . git commit --no-gpg-sign -m \"increment counter-1 to 1\" cat counter-1.txt git push origin You will get this error: To /tmp/my-counters ! [rejected] my-counters-counter-1 -> my-counters-counter-1 (fetch first) error: failed to push some refs to '/tmp/my-counters' hint: Updates were rejected because the remote contains work that you do hint: not have locally. This is usually caused by another repository pushing hint: to the same ref. You may want to first integrate the remote changes hint: (e.g., 'git pull ...') before pushing again. hint: See the 'Note about fast-forwards' in 'git push --help' for details. You cannot update the reference because the previous commits created by process-1 would be lost. Git does not allow you to update the object if someone else has already changed it. So basically if you use Git to store your objects the only mechanism to avoid race conditions is optimistic locking. This way of using Git is like having an SQL table where you have version numbers for recording updates by default. That means every time you read a record you get the version number. When you update the record you check that the version number is still the same. The only difference compared with the normal SQL optimistic lock approach is that you always store the new version of the object, but you do not update the reference (pointer) to it. So you will continue retrieving the previous version. But what would happens if you try to push a reference with git push outside of the branch folder? Meaning using a custom reference like the one we have used before. The good news is that Git: REJECTS updating any remote reference that refers to an object not in the local git object store. REJECTS updating any remote reference that refers to a non-commit-object. REJECTS updating any remote reference that changes a commit-object into referring a non commit-object. REJECTS updating any remote reference that isn't a direct parent of the new-commit-object. (ie. non-fast-forward push). It only accepts fast forward commit reference updates. How to design your unit of work Since you only can control concurrency at the object level (references) you have to make sure that you design your aggregates in a way that each aggregate is a different reference (or branch if you use the second model). What does that mean? In the same example, you can have strict domain rules between counters. For example: You cannot have more than a certain number of counters. All counters cannot count more than 100. In those cases, you should have to define an object like a \"pool of counters\" and store all the values in the same object (branch). If we do not have any invariant between objects you can store each object in a different orphan branch. That way you can reduce conflicts and have a better performance. On the contrary, if you have some invariants with more than one object then you have to store the whole aggregate in the same branch, so you make sure we do not have any transactional inconsistencies. You could decide the storage method depending on the invariants declared in application. I recommend reading these articles to know the trade-offs of aggregate design. Atomic Git push Sometimes you will need to update the object but also to create other commits in others branches atomically. For example, if you want to update two objects at the same time. You could want to update both of them or neither of them. That is to say, you could want to have transactions. Fortunately, Git has a push option \u201c--atomic\u201d that does exactly that: \"Either all refs are updated, or on error, no refs are updated\u201d. So you could do something like: git push --atomic origin refs/heads/my-counters-counter-1 refs/heads/my-counters-counter-2 More info about Atomic pushes: Git 2.4 \u2014 atomic pushes, push to deploy, and more Git push command with --atomic option GitHub Git database GitHub API allows you to access Git objects directly. Links Projects using Git objects and references to store data https://graphite.dev/ https://dvc.org/doc/user-guide/experiment-management/experiments-overview#how-does-dvc-track-experiments Talks Using Git as a NoSql Database by Kenneth Truyers Git the NoSQL Database by Brandon Keepers Articles How Git truly works The Biggest Misconception About Git Books Git Pro - Chapter 5.3 - Maintaining a Project - Section Tagging Your Releases Back to home","title":"Using Git as a key-value database"},{"location":"015_How-to-use-Git-as-a-database/#using-git-as-a-key-value-database","text":"Obviously you can store whatever you want in a Git repository but in this article we will see how to use the Git internal data structures to store and retrieve data. Where to store things Using Git Objects Using Git References Store only the latest state Store state change history How to solve race conditions Optimistic concurrency control Atomic Git push GitHub Git database Links Projects using Git objects and references to store data Talks Articles Books","title":"Using Git as a key-value database"},{"location":"015_How-to-use-Git-as-a-database/#where-to-store-things","text":"With Git you can store data in two different ways: Git objects References Those are the two ways Git stores data internally.","title":"Where to store things?"},{"location":"015_How-to-use-Git-as-a-database/#using-git-objects","text":"Git internally uses a key-value database with only 4 types of objects : blobs , trees , commits and annotated tags . Each object is stored in the database and the way to reference the object is by using its sha1 (a checksum of the content). For example, you can insert a new object in the database with: cd /tmp mkdir test cd test git init echo 'test content' | git hash-object -w --stdin d670460b4b4aece5915caf5c68d12f560a9fe3e4 The last command output is the sha1 of the new object. You can get the object content back using that sha1: git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4 This database is immutable. You can only add new content. If you are curious where Git stores those objects you can run this command: $ tree .git/ .git/ \u251c\u2500\u2500 branches \u251c\u2500\u2500 config \u251c\u2500\u2500 description \u251c\u2500\u2500 HEAD \u251c\u2500\u2500 hooks \u2502 \u251c\u2500\u2500 applypatch-msg.sample \u2502 \u251c\u2500\u2500 commit-msg.sample \u2502 \u251c\u2500\u2500 fsmonitor-watchman.sample \u2502 \u251c\u2500\u2500 post-update.sample \u2502 \u251c\u2500\u2500 pre-applypatch.sample \u2502 \u251c\u2500\u2500 pre-commit.sample \u2502 \u251c\u2500\u2500 pre-merge-commit.sample \u2502 \u251c\u2500\u2500 prepare-commit-msg.sample \u2502 \u251c\u2500\u2500 pre-push.sample \u2502 \u251c\u2500\u2500 pre-rebase.sample \u2502 \u251c\u2500\u2500 pre-receive.sample \u2502 \u251c\u2500\u2500 push-to-checkout.sample \u2502 \u2514\u2500\u2500 update.sample \u251c\u2500\u2500 info \u2502 \u2514\u2500\u2500 exclude \u251c\u2500\u2500 objects \u2502 \u251c\u2500\u2500 d6 \u2502 \u2502 \u2514\u2500\u2500 70460b4b4aece5915caf5c68d12f560a9fe3e4 \u2502 \u251c\u2500\u2500 info \u2502 \u2514\u2500\u2500 pack \u2514\u2500\u2500 refs \u251c\u2500\u2500 heads \u2514\u2500\u2500 tags 10 directories, 18 files You can see the file .git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 . There it is where Git stores the object.","title":"Using Git Objects"},{"location":"015_How-to-use-Git-as-a-database/#using-git-references","text":"Git has a directory .git/refs which contains files that are the references . Each file contains a sha1 of a database object. That means references are lia alias for objects. They allow you to reference objects in the database with a more readable name. If you want to get the content from the previous example but do not want to use the sha1, you could create a reference like this: git update-ref refs/my-objects/object-1 d670460b4b4aece5915caf5c68d12f560a9fe3e4 The reference is a pointer or alias for the object hash you have inserted in the database before. And now you can use the reference to get the content: $ git cat-file -p refs/my-objects/object-1 test content NOTICE: we are using a custom reference name. You can use any name and path you want. This database is a mutable database. You can change references to point to different Git objects. You can create new references in any fork of the repository and push them to any remote repository. There are some special references handled by Git: $ tree -al .git/refs/ .git/refs/ \u251c\u2500\u2500 heads \u251c\u2500\u2500 my-objects \u2502 \u2514\u2500\u2500 object-1 \u2514\u2500\u2500 tags 3 directories, 1 file Branches consist only on references pointing to the latest commit object hash in a sequence of commits. When you run a git push command Git tries to update a reference in a remote repository. Git provides only those basic low-level databases to store things: objects and references . You can use them in different ways. We have seen at least two different models: Store only the latest state. Store state change history (commits).","title":"Using Git References"},{"location":"015_How-to-use-Git-as-a-database/#store-only-the-latest-state","text":"You can store your data inside blob objects. When you want to update the version of your object you can store a new object. You can use a reference to retrieve the blob object. You also need to prevent the Git Garbage Collector from removing the object. If the blob object is not referenced anywhere it could be deleted. Thi diagram shows how to different processes can write objects: Pros: It is very simple. You only need to use two low level Git commits to store and retrieve your data and the very well-known porcelain commands to move data between repositories: pull and push . Cons: You cannot checkout the reference because it does not point to a commit. $ git checkout refs/my-objects/object-1 fatal: reference is not a tree: refs/my-objects/object-1 You cannot follow changes on the object because each new object version is not linked to the previous one. It is like a standard database. If you want to keep a history of your changes you can do it by yourself or use the next model. The model generates a lot of references since we need a reference for each object.","title":"Store only the latest state"},{"location":"015_How-to-use-Git-as-a-database/#store-state-change-history","text":"The previous solution allows you to store objects like a key-value database. But you can take full advantage of Git by using the other available objects. When you update a blob object you could create a commit. cd /tmp mkdir test cd test git init git checkout --orphan \"my-objects-object-1\" echo \"test content\" > object-1.txt git add . git commit --no-gpg-sign -m \"add object-1.txt\" You can get the object with: git checkout my-objects-object-1 && cat object-1.txt But actually the object value is accessible directly just like an standard file. All you need to do is checkout the reference (the branch) we are using to store the object. git checkout my-objects-object-1 && cat object-1.txt $ tree -al .git/refs/ .git/refs/ \u251c\u2500\u2500 heads \u2502 \u2514\u2500\u2500 my-objects-object-1 \u2514\u2500\u2500 tags Pros: You can add metadata for every database operation in the commit message. You can easily get the data using the Git Porcelain commands. You have the history of changes for your objects. Cons: It is more complex than the previous solution. It generates a lot of references too. One per object. This model uses an orphan branch for each object. An \"orphan\" branch is a branch that is not connected to any other branch. That means the first commit does not have any ancestors.","title":"Store state change history"},{"location":"015_How-to-use-Git-as-a-database/#how-to-solve-race-conditions","text":"We have seen two possible models to use Git to store your data as a key-value database. But does this database implementation offer you a way to handle race conditions? At some point, you are going to have two processes reading the same object and trying to update it at the same time. One of them is going to overwrite a previous value. We can create an example where we have a \u201ctable\u201d with counters. We insert the first object with a counter starting at 0. cd /tmp mkdir my-counters cd my-counters/ git init git checkout -b my-counters-counter-1 echo \"0\" > counter-1.txt git add . git commit --no-gpg-sign -m \"initialize counter-1\" cat counter-1.txt An independent processes could checkout the repository and increment the counter. After cloning the repository you have an old version of the data because other processes could have cloned and updated the counter. Git is a decentralized data structure and the only way to reconciliate things is by using pull and push commands. Git will tell you when you are trying to merge data with conflicts.","title":"How to solve race conditions"},{"location":"015_How-to-use-Git-as-a-database/#optimistic-concurrency-control","text":"We normally have two options to fix that problem with normal databases, you can either lock the record when you want to modify it (pessimistic locking) or try to modify it always and make the update fail if the record has changed (optimistic locking). Git only allows us to use the optimistic approach . When you try to \u201cpush\u201d your object version by updating the reference in the origin repo you will get an error if the reference (branch) was already changed. We can reproduce the conflict in our previous example. We are going to clone the repository twice in two different folders. cd /tmp git clone /tmp/my-counters my-counters-process-1 cd /tmp/my-counters-process-1/ git checkout my-counters-counter-1 cat counter-1.txt cd /tmp git clone /tmp/my-counters my-counters-process-2 cd /tmp/my-counters-process-2/ git checkout my-counters-counter-1 cat counter-1.txt The last output line should show the value 0 for the counter-1 . Now we can increment the counter with the first process and push the new value. cd /tmp/my-counters-process-1 git checkout my-counters-counter-1 echo \"1\" > counter-1.txt git add . git commit --no-gpg-sign -m \"increment counter-1 to 1\" echo \"2\" > counter-1.txt git add . git commit --no-gpg-sign -m \"increment counter-1 to 2\" cat counter-1.txt If you try to push the counter you are going to have this error: git push origin \u2026 ! [remote rejected] counter-1 -> counter-1 (branch is currently checked out) error: failed to push some refs to '/tmp/my-counters' That is because you are on the same branch in the origin repository. You only need to checkout a different branch in the origin repo. cd /tmp/my-counters git checkout --orphan another-branch Got bak to the process-1 folder and push the new value. cd /tmp/my-counters-process-1/ git push origin Now, the output should be like: Enumerating objects: 8, done. Counting objects: 100% (8/8), done. Delta compression using up to 8 threads Compressing objects: 100% (2/2), done. Writing objects: 100% (6/6), 482 bytes | 482.00 KiB/s, done. Total 6 (delta 0), reused 0 (delta 0), pack-reused 0 To /tmp/my-counters 7614015..ba3cbfb my-counters-counter-1 -> my-counters-counter-1 You have updated the origin (our database) with a new value. Now, if you try to push changes from the process-2 : cd /tmp/my-counters-process-2 git checkout my-counters-counter-1 echo \"1\" > counter-1.txt git add . git commit --no-gpg-sign -m \"increment counter-1 to 1\" cat counter-1.txt git push origin You will get this error: To /tmp/my-counters ! [rejected] my-counters-counter-1 -> my-counters-counter-1 (fetch first) error: failed to push some refs to '/tmp/my-counters' hint: Updates were rejected because the remote contains work that you do hint: not have locally. This is usually caused by another repository pushing hint: to the same ref. You may want to first integrate the remote changes hint: (e.g., 'git pull ...') before pushing again. hint: See the 'Note about fast-forwards' in 'git push --help' for details. You cannot update the reference because the previous commits created by process-1 would be lost. Git does not allow you to update the object if someone else has already changed it. So basically if you use Git to store your objects the only mechanism to avoid race conditions is optimistic locking. This way of using Git is like having an SQL table where you have version numbers for recording updates by default. That means every time you read a record you get the version number. When you update the record you check that the version number is still the same. The only difference compared with the normal SQL optimistic lock approach is that you always store the new version of the object, but you do not update the reference (pointer) to it. So you will continue retrieving the previous version. But what would happens if you try to push a reference with git push outside of the branch folder? Meaning using a custom reference like the one we have used before. The good news is that Git: REJECTS updating any remote reference that refers to an object not in the local git object store. REJECTS updating any remote reference that refers to a non-commit-object. REJECTS updating any remote reference that changes a commit-object into referring a non commit-object. REJECTS updating any remote reference that isn't a direct parent of the new-commit-object. (ie. non-fast-forward push). It only accepts fast forward commit reference updates.","title":"Optimistic concurrency control"},{"location":"015_How-to-use-Git-as-a-database/#how-to-design-your-unit-of-work","text":"Since you only can control concurrency at the object level (references) you have to make sure that you design your aggregates in a way that each aggregate is a different reference (or branch if you use the second model). What does that mean? In the same example, you can have strict domain rules between counters. For example: You cannot have more than a certain number of counters. All counters cannot count more than 100. In those cases, you should have to define an object like a \"pool of counters\" and store all the values in the same object (branch). If we do not have any invariant between objects you can store each object in a different orphan branch. That way you can reduce conflicts and have a better performance. On the contrary, if you have some invariants with more than one object then you have to store the whole aggregate in the same branch, so you make sure we do not have any transactional inconsistencies. You could decide the storage method depending on the invariants declared in application. I recommend reading these articles to know the trade-offs of aggregate design.","title":"How to design your unit of work"},{"location":"015_How-to-use-Git-as-a-database/#atomic-git-push","text":"Sometimes you will need to update the object but also to create other commits in others branches atomically. For example, if you want to update two objects at the same time. You could want to update both of them or neither of them. That is to say, you could want to have transactions. Fortunately, Git has a push option \u201c--atomic\u201d that does exactly that: \"Either all refs are updated, or on error, no refs are updated\u201d. So you could do something like: git push --atomic origin refs/heads/my-counters-counter-1 refs/heads/my-counters-counter-2 More info about Atomic pushes: Git 2.4 \u2014 atomic pushes, push to deploy, and more Git push command with --atomic option","title":"Atomic Git push"},{"location":"015_How-to-use-Git-as-a-database/#github-git-database","text":"GitHub API allows you to access Git objects directly.","title":"GitHub Git database"},{"location":"015_How-to-use-Git-as-a-database/#links","text":"","title":"Links"},{"location":"015_How-to-use-Git-as-a-database/#projects-using-git-objects-and-references-to-store-data","text":"https://graphite.dev/ https://dvc.org/doc/user-guide/experiment-management/experiments-overview#how-does-dvc-track-experiments","title":"Projects using Git objects and references to store data"},{"location":"015_How-to-use-Git-as-a-database/#talks","text":"Using Git as a NoSql Database by Kenneth Truyers Git the NoSQL Database by Brandon Keepers","title":"Talks"},{"location":"015_How-to-use-Git-as-a-database/#articles","text":"How Git truly works The Biggest Misconception About Git","title":"Articles"},{"location":"015_How-to-use-Git-as-a-database/#books","text":"Git Pro - Chapter 5.3 - Maintaining a Project - Section Tagging Your Releases Back to home","title":"Books"}]}